<!-- Created by tixml2svd; https://github.com/dhoove/tixml2svd -->
<?xml version="1.0" encoding="utf-8"?>
<device>
  <vendor>Texas Instruments</vendor>
  <vendorID>TI</vendorID> 
  <name>CC32xxSF</name>
  <series>ARMCM4</series>
  <version>1.0</version>
  <description>SimpleLink CC32xxSF Wireless MCU</description>
  <cpu>
    <name>CM4</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>32</size>
  <access>read-write</access>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>WDT</name>
      <baseAddress>0x40000000</baseAddress>
      <registers>
        <register>
          <name>LOAD</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>LOAD</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>VALUE</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>VALUE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>CTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>ICR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>RIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>MIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TEST</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>TEST</description>
          <fields>
            <field>
              <name>STALL_EN</name>
              <description>[11:10] Watchdog stall enable</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LOCK</name>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <description>LOCK</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOA0</name>
      <baseAddress>0x40004000</baseAddress>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits [9:2]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits [9:2]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR2R</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR4R</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR8R</name>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <description>0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODR</name>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <description>0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PUR</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDR</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SLR</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEN</name>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <description>0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AMSEL</name>
          <addressOffset>0x528</addressOffset>
          <size>32</size>
          <description>0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCTL</name>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCCTL</name>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x534</addressOffset>
          <size>32</size>
          <description>0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SI</name>
          <addressOffset>0x538</addressOffset>
          <size>32</size>
          <description>0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID4</name>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <description>0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID5</name>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <description>0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID6</name>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <description>0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID7</name>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <description>0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID0</name>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <description>0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID1</name>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <description>0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID2</name>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <description>0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID3</name>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <description>0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID0</name>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <description>0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID1</name>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <description>0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID2</name>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <description>0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID3</name>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <description>0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOA1</name>
      <baseAddress>0x40005000</baseAddress>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits [9:2]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits [9:2]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR2R</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR4R</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR8R</name>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <description>0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODR</name>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <description>0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PUR</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDR</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SLR</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEN</name>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <description>0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AMSEL</name>
          <addressOffset>0x528</addressOffset>
          <size>32</size>
          <description>0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCTL</name>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCCTL</name>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x534</addressOffset>
          <size>32</size>
          <description>0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SI</name>
          <addressOffset>0x538</addressOffset>
          <size>32</size>
          <description>0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID4</name>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <description>0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID5</name>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <description>0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID6</name>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <description>0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID7</name>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <description>0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID0</name>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <description>0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID1</name>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <description>0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID2</name>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <description>0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID3</name>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <description>0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID0</name>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <description>0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID1</name>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <description>0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID2</name>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <description>0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID3</name>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <description>0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOA2</name>
      <baseAddress>0x40006000</baseAddress>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits [9:2]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits [9:2]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR2R</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR4R</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR8R</name>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <description>0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODR</name>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <description>0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PUR</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDR</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SLR</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEN</name>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <description>0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AMSEL</name>
          <addressOffset>0x528</addressOffset>
          <size>32</size>
          <description>0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCTL</name>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCCTL</name>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x534</addressOffset>
          <size>32</size>
          <description>0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SI</name>
          <addressOffset>0x538</addressOffset>
          <size>32</size>
          <description>0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID4</name>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <description>0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID5</name>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <description>0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID6</name>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <description>0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID7</name>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <description>0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID0</name>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <description>0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID1</name>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <description>0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID2</name>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <description>0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID3</name>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <description>0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID0</name>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <description>0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID1</name>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <description>0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID2</name>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <description>0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID3</name>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <description>0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOA3</name>
      <baseAddress>0x40007000</baseAddress>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits [9:2]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits [9:2]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR2R</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR4R</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR8R</name>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <description>0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODR</name>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <description>0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PUR</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDR</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SLR</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEN</name>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <description>0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AMSEL</name>
          <addressOffset>0x528</addressOffset>
          <size>32</size>
          <description>0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCTL</name>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCCTL</name>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x534</addressOffset>
          <size>32</size>
          <description>0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SI</name>
          <addressOffset>0x538</addressOffset>
          <size>32</size>
          <description>0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID4</name>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <description>0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID5</name>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <description>0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID6</name>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <description>0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID7</name>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <description>0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID0</name>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <description>0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID1</name>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <description>0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID2</name>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <description>0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID3</name>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <description>0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID0</name>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <description>0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID1</name>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <description>0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID2</name>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <description>0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID3</name>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <description>0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UARTA0</name>
      <baseAddress>0x4000C000</baseAddress>
      <registers>
        <register>
          <name>DR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>DR</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[7:0] Data Transmitted or Received</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSR_ECR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>RSR_ECR</description>
          <fields>
            <field>
              <name>UART_ECR_DATA</name>
              <description>[7:0] Error Clear</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>FR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ILPR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>ILPR</description>
          <fields>
            <field>
              <name>ILPDVSR</name>
              <description>[7:0] IrDA Low-Power Divisor</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBRD</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>IBRD</description>
          <fields>
            <field>
              <name>DIVINT</name>
              <description>[15:0] Integer Baud-Rate Divisor</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FBRD</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>FBRD</description>
          <fields>
            <field>
              <name>DIVFRAC</name>
              <description>[5:0] Fractional Baud-Rate Divisor</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCRH</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>LCRH</description>
          <fields>
            <field>
              <name>WLEN</name>
              <description>[6:5] UART Word Length 0x00000000 : UART_LCRH_WLEN_5 : 5 bits (default) 0x00000020 : UART_LCRH_WLEN_6 : 6 bits 0x00000040 : UART_LCRH_WLEN_7 : 7 bits 0x00000060 : UART_LCRH_WLEN_8 : 8 bits</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>CTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IFLS</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>IFLS</description>
          <fields>
            <field>
              <name>RX</name>
              <description>[5:3] UART Receive Interrupt FIFO Level Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TX</name>
              <description>[2:0] UART Transmit Interrupt FIFO Level Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>IM</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>RIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>MIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>ICR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>DMACTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCTL</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>LCTL</description>
          <fields>
            <field>
              <name>BLEN</name>
              <description>[5:4] Sync Break Length 0x00000000 : UART_LCTL_BLEN_13T : Sync break length is 13T bits (default) 0x00000010 : UART_LCTL_BLEN_14T : Sync break length is 14T bits 0x00000020 : UART_LCTL_BLEN_15T : Sync break length is 15T bits 0x00000030 : UART_LCTL_BLEN_16T : Sync break length is 16T bits</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LSS</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>LSS</description>
          <fields>
            <field>
              <name>TSS</name>
              <description>[15:0] Timer Snap Shot</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LTIM</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>LTIM</description>
          <fields>
            <field>
              <name>TIMER</name>
              <description>[15:0] Timer Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_9BITADDR</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>UART_9BITADDR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_9BITAMASK</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>UART_9BITAMASK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>PP</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC</name>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <description>CC</description>
          <fields>
            <field>
              <name>CS</name>
              <description>[3:0] UART Baud Clock Source 0x00000005 : UART_CC_CS_PIOSC : PIOSC 0x00000000 : UART_CC_CS_SYSCLK : The system clock (default)</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UARTA1</name>
      <baseAddress>0x4000D000</baseAddress>
      <registers>
        <register>
          <name>DR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>DR</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[7:0] Data Transmitted or Received</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSR_ECR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>RSR_ECR</description>
          <fields>
            <field>
              <name>UART_ECR_DATA</name>
              <description>[7:0] Error Clear</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>FR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ILPR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>ILPR</description>
          <fields>
            <field>
              <name>ILPDVSR</name>
              <description>[7:0] IrDA Low-Power Divisor</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBRD</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>IBRD</description>
          <fields>
            <field>
              <name>DIVINT</name>
              <description>[15:0] Integer Baud-Rate Divisor</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FBRD</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>FBRD</description>
          <fields>
            <field>
              <name>DIVFRAC</name>
              <description>[5:0] Fractional Baud-Rate Divisor</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCRH</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>LCRH</description>
          <fields>
            <field>
              <name>WLEN</name>
              <description>[6:5] UART Word Length 0x00000000 : UART_LCRH_WLEN_5 : 5 bits (default) 0x00000020 : UART_LCRH_WLEN_6 : 6 bits 0x00000040 : UART_LCRH_WLEN_7 : 7 bits 0x00000060 : UART_LCRH_WLEN_8 : 8 bits</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>CTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IFLS</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>IFLS</description>
          <fields>
            <field>
              <name>RX</name>
              <description>[5:3] UART Receive Interrupt FIFO Level Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TX</name>
              <description>[2:0] UART Transmit Interrupt FIFO Level Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>IM</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>RIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>MIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>ICR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>DMACTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCTL</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>LCTL</description>
          <fields>
            <field>
              <name>BLEN</name>
              <description>[5:4] Sync Break Length 0x00000000 : UART_LCTL_BLEN_13T : Sync break length is 13T bits (default) 0x00000010 : UART_LCTL_BLEN_14T : Sync break length is 14T bits 0x00000020 : UART_LCTL_BLEN_15T : Sync break length is 15T bits 0x00000030 : UART_LCTL_BLEN_16T : Sync break length is 16T bits</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LSS</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>LSS</description>
          <fields>
            <field>
              <name>TSS</name>
              <description>[15:0] Timer Snap Shot</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LTIM</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>LTIM</description>
          <fields>
            <field>
              <name>TIMER</name>
              <description>[15:0] Timer Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_9BITADDR</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>UART_9BITADDR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_9BITAMASK</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>UART_9BITAMASK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>PP</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC</name>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <description>CC</description>
          <fields>
            <field>
              <name>CS</name>
              <description>[3:0] UART Baud Clock Source 0x00000005 : UART_CC_CS_PIOSC : PIOSC 0x00000000 : UART_CC_CS_SYSCLK : The system clock (default)</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2CA0</name>
      <baseAddress>0x40020000</baseAddress>
      <registers>
        <register>
          <name>MSA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>MSA</description>
          <fields>
            <field>
              <name>SA</name>
              <description>[7:1] I2C Slave Address</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCS</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>MCS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MDR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>MDR</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[7:0] Data Transferred</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTPR</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>MTPR</description>
          <fields>
            <field>
              <name>TPR</name>
              <description>[6:0] SCL Clock Period</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIMR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>MIMR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MRIS</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>MRIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MMIS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>MMIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MICR</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>MICR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>MCR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCLKOCNT</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>MCLKOCNT</description>
          <fields>
            <field>
              <name>CNTL</name>
              <description>[7:0] I2C Master Count</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MBMON</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>MBMON</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MBLEN</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>MBLEN</description>
          <fields>
            <field>
              <name>CNTL</name>
              <description>[7:0] I2C Burst Length</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MBCNT</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>MBCNT</description>
          <fields>
            <field>
              <name>CNTL</name>
              <description>[7:0] I2C Master Burst Count</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SOAR</name>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <description>SOAR</description>
          <fields>
            <field>
              <name>OAR</name>
              <description>[6:0] I2C Slave Own Address</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SCSR</name>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <description>SCSR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SDR</name>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <description>SDR</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[7:0] Data for Transfer</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SIMR</name>
          <addressOffset>0x80C</addressOffset>
          <size>32</size>
          <description>SIMR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRIS</name>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <description>SRIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SMIS</name>
          <addressOffset>0x814</addressOffset>
          <size>32</size>
          <description>SMIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SICR</name>
          <addressOffset>0x818</addressOffset>
          <size>32</size>
          <description>SICR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SOAR2</name>
          <addressOffset>0x81C</addressOffset>
          <size>32</size>
          <description>SOAR2</description>
          <fields>
            <field>
              <name>OAR2</name>
              <description>[6:0] I2C Slave Own Address 2</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SACKCTL</name>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <description>SACKCTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FIFODATA</name>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <description>FIFODATA</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[7:0] I2C FIFO Data Byte</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FIFOCTL</name>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <description>FIFOCTL</description>
          <fields>
            <field>
              <name>RXTRIG</name>
              <description>[18:16] RX FIFO Trigger</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TXTRIG</name>
              <description>[2:0] TX FIFO Trigger</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FIFOSTATUS</name>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <description>FIFOSTATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSMUXSEL0</name>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <description>OBSMUXSEL0</description>
          <fields>
            <field>
              <name>LN3</name>
              <description>[26:24] Observation Mux Lane 3</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>LN2</name>
              <description>[18:16] Observation Mux Lane 2</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LN1</name>
              <description>[10:8] Observation Mux Lane 1</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LN0</name>
              <description>[2:0] Observation Mux Lane 0</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSMUXSEL1</name>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <description>OBSMUXSEL1</description>
          <fields>
            <field>
              <name>LN7</name>
              <description>[26:24] Observation Mux Lane 7</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>LN6</name>
              <description>[18:16] Observation Mux Lane 6</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LN5</name>
              <description>[10:8] Observation Mux Lane 5</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LN4</name>
              <description>[2:0] Observation Mux Lane 4</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MUXROUTE</name>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <description>MUXROUTE</description>
          <fields>
            <field>
              <name>LN7ROUTE</name>
              <description>[30:28] Lane 7 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LN6ROUTE</name>
              <description>[26:24] Lane 6 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>LN5ROUTE</name>
              <description>[22:20] Lane 5 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>LN4ROUTE</name>
              <description>[18:16] Lane 4 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LN3ROUTE</name>
              <description>[14:12] Lane 3 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LN2ROUTE</name>
              <description>[10:8] Lane 2 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LN1ROUTE</name>
              <description>[6:4] Lane 1 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LN0ROUTE</name>
              <description>[2:0] Lane 0 output is routed to the lane pointed to by the offset in this bit field</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PV</name>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <description>PV</description>
          <fields>
            <field>
              <name>MAJOR</name>
              <description>[15:8] Major Revision</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MINOR</name>
              <description>[7:0] Minor Revision</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>PP</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC</name>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <description>PC</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC</name>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <description>CC</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOA4</name>
      <baseAddress>0x40024000</baseAddress>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits [9:2]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits [9:2]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR2R</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR4R</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR8R</name>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <description>0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODR</name>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <description>0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PUR</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDR</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SLR</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEN</name>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <description>0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AMSEL</name>
          <addressOffset>0x528</addressOffset>
          <size>32</size>
          <description>0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCTL</name>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCCTL</name>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <description>This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x534</addressOffset>
          <size>32</size>
          <description>0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SI</name>
          <addressOffset>0x538</addressOffset>
          <size>32</size>
          <description>0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID4</name>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <description>0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID5</name>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <description>0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID6</name>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <description>0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID7</name>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <description>0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID0</name>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <description>0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID1</name>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <description>0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID2</name>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <description>0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PERIPHID3</name>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <description>0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID0</name>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <description>0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID1</name>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <description>0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID2</name>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <description>0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PCELLID3</name>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <description>0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIMERA0</name>
      <baseAddress>0x40030000</baseAddress>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM Configuration</description>
          <fields>
            <field>
              <name>CFG</name>
              <description>[2:0] GPTM Configuration</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Mode</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Mode</description>
          <fields>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>GPTM Control ##### GARNET BEGIN #####</description>
          <fields>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM Synchronize ##### GARNET END #####</description>
          <fields>
            <field>
              <name>SYNC11</name>
              <description>[23:22] Synchronize GPTM Timer 11</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>SYNC10</name>
              <description>[21:20] Synchronize GPTM Timer 10</description>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SYNC9</name>
              <description>[19:18] Synchronize GPTM Timer 9</description>
              <bitWidth>2</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SYNC8</name>
              <description>[17:16] Synchronize GPTM Timer 8</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SYNC7</name>
              <description>[15:14] Synchronize GPTM Timer 7</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SYNC6</name>
              <description>[13:12] Synchronize GPTM Timer 6</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SYNC5</name>
              <description>[11:10] Synchronize GPTM Timer 5</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SYNC4</name>
              <description>[9:8] Synchronize GPTM Timer 4</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM Timer 3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM Timer 2</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Mask</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>GPTM Raw Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM Masked Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Clear</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Interval Load</description>
          <fields>
            <field>
              <name>TAILRH</name>
              <description>[31:16] GPTM Timer A Interval Load Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAILRL</name>
              <description>[15:0] GPTM Timer A Interval Load Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Interval Load</description>
          <fields>
            <field>
              <name>TBILRL</name>
              <description>[15:0] GPTM Timer B Interval Load Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale</description>
          <fields>
            <field>
              <name>TAPSRH</name>
              <description>[15:8] GPTM Timer A Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale</description>
          <fields>
            <field>
              <name>TBPSRH</name>
              <description>[15:8] GPTM Timer B Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM TimerA Prescale Match</description>
          <fields>
            <field>
              <name>TAPSMRH</name>
              <description>[15:8] GPTM Timer A Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPTM TimerA Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM TimerB Prescale Match</description>
          <fields>
            <field>
              <name>TBPSMRH</name>
              <description>[15:8] GPTM Timer B Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPTM TimerB Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A</description>
          <fields>
            <field>
              <name>TARH</name>
              <description>[31:16] GPTM Timer A Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TARL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B</description>
          <fields>
            <field>
              <name>TBRL</name>
              <description>[23:0] GPTM Timer B</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Value</description>
          <fields>
            <field>
              <name>TAVH</name>
              <description>[31:16] GPTM Timer A Value High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAVL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Value</description>
          <fields>
            <field>
              <name>TBVL</name>
              <description>[15:0] GPTM Timer B Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RTCPD</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>GPTM RTC Predivide</description>
          <fields>
            <field>
              <name>RTCPD</name>
              <description>[15:0] RTC Predivide Counter Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Snapshot</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>GPTM DMA Event</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>GPTM Peripheral Properties ***************************************************************************</description>
          <fields>
            <field>
              <name>SIZE</name>
              <description>[3:0] Count Size</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIMERA1</name>
      <baseAddress>0x40031000</baseAddress>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM Configuration</description>
          <fields>
            <field>
              <name>CFG</name>
              <description>[2:0] GPTM Configuration</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Mode</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Mode</description>
          <fields>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>GPTM Control ##### GARNET BEGIN #####</description>
          <fields>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM Synchronize ##### GARNET END #####</description>
          <fields>
            <field>
              <name>SYNC11</name>
              <description>[23:22] Synchronize GPTM Timer 11</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>SYNC10</name>
              <description>[21:20] Synchronize GPTM Timer 10</description>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SYNC9</name>
              <description>[19:18] Synchronize GPTM Timer 9</description>
              <bitWidth>2</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SYNC8</name>
              <description>[17:16] Synchronize GPTM Timer 8</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SYNC7</name>
              <description>[15:14] Synchronize GPTM Timer 7</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SYNC6</name>
              <description>[13:12] Synchronize GPTM Timer 6</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SYNC5</name>
              <description>[11:10] Synchronize GPTM Timer 5</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SYNC4</name>
              <description>[9:8] Synchronize GPTM Timer 4</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM Timer 3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM Timer 2</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Mask</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>GPTM Raw Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM Masked Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Clear</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Interval Load</description>
          <fields>
            <field>
              <name>TAILRH</name>
              <description>[31:16] GPTM Timer A Interval Load Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAILRL</name>
              <description>[15:0] GPTM Timer A Interval Load Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Interval Load</description>
          <fields>
            <field>
              <name>TBILRL</name>
              <description>[15:0] GPTM Timer B Interval Load Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale</description>
          <fields>
            <field>
              <name>TAPSRH</name>
              <description>[15:8] GPTM Timer A Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale</description>
          <fields>
            <field>
              <name>TBPSRH</name>
              <description>[15:8] GPTM Timer B Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM TimerA Prescale Match</description>
          <fields>
            <field>
              <name>TAPSMRH</name>
              <description>[15:8] GPTM Timer A Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPTM TimerA Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM TimerB Prescale Match</description>
          <fields>
            <field>
              <name>TBPSMRH</name>
              <description>[15:8] GPTM Timer B Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPTM TimerB Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A</description>
          <fields>
            <field>
              <name>TARH</name>
              <description>[31:16] GPTM Timer A Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TARL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B</description>
          <fields>
            <field>
              <name>TBRL</name>
              <description>[23:0] GPTM Timer B</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Value</description>
          <fields>
            <field>
              <name>TAVH</name>
              <description>[31:16] GPTM Timer A Value High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAVL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Value</description>
          <fields>
            <field>
              <name>TBVL</name>
              <description>[15:0] GPTM Timer B Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RTCPD</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>GPTM RTC Predivide</description>
          <fields>
            <field>
              <name>RTCPD</name>
              <description>[15:0] RTC Predivide Counter Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Snapshot</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>GPTM DMA Event</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>GPTM Peripheral Properties ***************************************************************************</description>
          <fields>
            <field>
              <name>SIZE</name>
              <description>[3:0] Count Size</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIMERA2</name>
      <baseAddress>0x40032000</baseAddress>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM Configuration</description>
          <fields>
            <field>
              <name>CFG</name>
              <description>[2:0] GPTM Configuration</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Mode</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Mode</description>
          <fields>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>GPTM Control ##### GARNET BEGIN #####</description>
          <fields>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM Synchronize ##### GARNET END #####</description>
          <fields>
            <field>
              <name>SYNC11</name>
              <description>[23:22] Synchronize GPTM Timer 11</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>SYNC10</name>
              <description>[21:20] Synchronize GPTM Timer 10</description>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SYNC9</name>
              <description>[19:18] Synchronize GPTM Timer 9</description>
              <bitWidth>2</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SYNC8</name>
              <description>[17:16] Synchronize GPTM Timer 8</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SYNC7</name>
              <description>[15:14] Synchronize GPTM Timer 7</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SYNC6</name>
              <description>[13:12] Synchronize GPTM Timer 6</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SYNC5</name>
              <description>[11:10] Synchronize GPTM Timer 5</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SYNC4</name>
              <description>[9:8] Synchronize GPTM Timer 4</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM Timer 3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM Timer 2</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Mask</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>GPTM Raw Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM Masked Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Clear</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Interval Load</description>
          <fields>
            <field>
              <name>TAILRH</name>
              <description>[31:16] GPTM Timer A Interval Load Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAILRL</name>
              <description>[15:0] GPTM Timer A Interval Load Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Interval Load</description>
          <fields>
            <field>
              <name>TBILRL</name>
              <description>[15:0] GPTM Timer B Interval Load Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale</description>
          <fields>
            <field>
              <name>TAPSRH</name>
              <description>[15:8] GPTM Timer A Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale</description>
          <fields>
            <field>
              <name>TBPSRH</name>
              <description>[15:8] GPTM Timer B Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM TimerA Prescale Match</description>
          <fields>
            <field>
              <name>TAPSMRH</name>
              <description>[15:8] GPTM Timer A Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPTM TimerA Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM TimerB Prescale Match</description>
          <fields>
            <field>
              <name>TBPSMRH</name>
              <description>[15:8] GPTM Timer B Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPTM TimerB Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A</description>
          <fields>
            <field>
              <name>TARH</name>
              <description>[31:16] GPTM Timer A Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TARL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B</description>
          <fields>
            <field>
              <name>TBRL</name>
              <description>[23:0] GPTM Timer B</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Value</description>
          <fields>
            <field>
              <name>TAVH</name>
              <description>[31:16] GPTM Timer A Value High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAVL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Value</description>
          <fields>
            <field>
              <name>TBVL</name>
              <description>[15:0] GPTM Timer B Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RTCPD</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>GPTM RTC Predivide</description>
          <fields>
            <field>
              <name>RTCPD</name>
              <description>[15:0] RTC Predivide Counter Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Snapshot</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>GPTM DMA Event</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>GPTM Peripheral Properties ***************************************************************************</description>
          <fields>
            <field>
              <name>SIZE</name>
              <description>[3:0] Count Size</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIMERA3</name>
      <baseAddress>0x40033000</baseAddress>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM Configuration</description>
          <fields>
            <field>
              <name>CFG</name>
              <description>[2:0] GPTM Configuration</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Mode</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Mode</description>
          <fields>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>GPTM Control ##### GARNET BEGIN #####</description>
          <fields>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A Event Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM Synchronize ##### GARNET END #####</description>
          <fields>
            <field>
              <name>SYNC11</name>
              <description>[23:22] Synchronize GPTM Timer 11</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>SYNC10</name>
              <description>[21:20] Synchronize GPTM Timer 10</description>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SYNC9</name>
              <description>[19:18] Synchronize GPTM Timer 9</description>
              <bitWidth>2</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SYNC8</name>
              <description>[17:16] Synchronize GPTM Timer 8</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SYNC7</name>
              <description>[15:14] Synchronize GPTM Timer 7</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SYNC6</name>
              <description>[13:12] Synchronize GPTM Timer 6</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SYNC5</name>
              <description>[11:10] Synchronize GPTM Timer 5</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SYNC4</name>
              <description>[9:8] Synchronize GPTM Timer 4</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM Timer 3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM Timer 2</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Mask</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>GPTM Raw Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM Masked Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM Interrupt Clear</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Interval Load</description>
          <fields>
            <field>
              <name>TAILRH</name>
              <description>[31:16] GPTM Timer A Interval Load Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAILRL</name>
              <description>[15:0] GPTM Timer A Interval Load Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Interval Load</description>
          <fields>
            <field>
              <name>TBILRL</name>
              <description>[15:0] GPTM Timer B Interval Load Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Match</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale</description>
          <fields>
            <field>
              <name>TAPSRH</name>
              <description>[15:8] GPTM Timer A Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale</description>
          <fields>
            <field>
              <name>TBPSRH</name>
              <description>[15:8] GPTM Timer B Prescale High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B Prescale ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM TimerA Prescale Match</description>
          <fields>
            <field>
              <name>TAPSMRH</name>
              <description>[15:8] GPTM Timer A Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPTM TimerA Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM TimerB Prescale Match</description>
          <fields>
            <field>
              <name>TBPSMRH</name>
              <description>[15:8] GPTM Timer B Prescale Match High Byte ##### GARNET END #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPTM TimerB Prescale Match ##### GARNET BEGIN #####</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A</description>
          <fields>
            <field>
              <name>TARH</name>
              <description>[31:16] GPTM Timer A Register High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TARL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>GPTM Timer B</description>
          <fields>
            <field>
              <name>TBRL</name>
              <description>[23:0] GPTM Timer B</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Value</description>
          <fields>
            <field>
              <name>TAVH</name>
              <description>[31:16] GPTM Timer A Value High</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TAVL</name>
              <description>[15:0] GPTM Timer A Register Low</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Value</description>
          <fields>
            <field>
              <name>TBVL</name>
              <description>[15:0] GPTM Timer B Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RTCPD</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>GPTM RTC Predivide</description>
          <fields>
            <field>
              <name>RTCPD</name>
              <description>[15:0] RTC Predivide Counter Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Snapshot</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Snapshot</description>
          <fields>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B Prescale Value</description>
          <fields>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B Prescaler Value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>GPTM DMA Event</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>GPTM Peripheral Properties ***************************************************************************</description>
          <fields>
            <field>
              <name>SIZE</name>
              <description>[3:0] Count Size</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>STACKDIE_CTRL</name>
      <baseAddress>0x400F5000</baseAddress>
      <registers>
        <register>
          <name>STK_UP_RESET</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Can be written only by Base Processor. Writing to this register will reset the stack processor reset will be de-asserted upon clearing this register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SR_MASTER_PRIORITY</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>This register defines who among base processor and stack processor have highest priority for Sram Access. Can be written only by Base Processor.</description>
          <fields>
            <field>
              <name>PRIORITY</name>
              <description>[1:0] 00 : Equal Priority 01 : Stack Processor have priority 10 : Base Processor have priority 11 : Unused</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STK_SR_ACC_CTL_BK2</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>In Spinlock mode this Register defines who among base processor and stack processor have access to Sram Bank2 right now. In Handshake mode this Register defines who among base processor and stack processor have access to Sram Bank2 and Bank3 right now. Its Clear only register and is set by hardware. Lower bit can be cleared only by Base Processor and Upper bit Cleared only by the Stack processor.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BASE_UP_ACC_REQ_BK2</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>In Spinlock mode whenever Base processor wants the access to Sram Bank2 it should request for it by writing into this register. It'll get interrupt whenever it is granted. In Handshake mode this bit will be set by Stack processor. Its a set only bit and is cleared by HW when the request is granted.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STK_UP_ACC_REQ_BK2</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>In Spinlock mode Whenever Stack processor wants the access to Sram Bank2 it should request for it by writing into this register. It'll get interrupt whenever it is granted. In Handshake mode this bit will be set by the Base processor. Its a set only bit and is cleared by HW when the request is granted.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STK_SR_ACC_CTL_BK3</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Register defines who among base processor and stack processor have access to Sram Bank3 right now. Its Clear only register and is set by hardware. Lower bit can be cleared only by Base Processor and Upper bit Cleared only by the Stack processor.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BASE_UP_ACC_REQ_BK3</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>In Spinlock mode whenever Base processor wants the access to Sram Bank3 it should request for it by writing into this register. It'll get interrupt whenever it is granted. In Handshake mode this bit will be set by Stack processor. Its a set only bit and is cleared by HW when the request is granted.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STK_UP_ACC_REQ_BK3</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>In Spinlock mode Whenever Stack processor wants the access to Sram Bank3 it should request for it by writing into this register. It'll get interrupt whenever it is granted. In Handshake mode this bit will be set by the Base processor. Its a set only bit and is cleared by HW when the request is granted.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RDSM_CFG_CPU</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Read State Machine timing configuration register. Generally Bit 4 and 3 will be identical. For stacked die always 43 are 0 and 6:5 == 1 for 120Mhz.</description>
          <fields>
            <field>
              <name>FLCLK_PULSE_WIDTH</name>
              <description>[7:6] Bank Clock Hi Time 00 : HCLK pulse 01 : 1 cycle of HCLK 10 : 1.5 cycles of HCLK 11 : 2 cycles of HCLK</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>READ_WAIT_STATE</name>
              <description>[3:0] Number of wait states inserted</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RDSM_CFG_EE</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Read State Machine timing configuration register. Generally Bit 4 and 3 will be identical. For stacked die always 43 are 0 and 6:5 == 1 for 120Mhz.</description>
          <fields>
            <field>
              <name>FLCLK_PULSE_WIDTH</name>
              <description>[7:6] Bank Clock Hi Time 00 : HCLK pulse 01 : 1 cycle of HCLK 10 : 1.5 cycles of HCLK 11 : 2 cycles of HCLK</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>READ_WAIT_STATE</name>
              <description>[3:0] Number of wait states inserted</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BASE_UP_IRQ_LOG</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Reading this register Base procesor will able to know the reason for the interrupt. This is clear only register - set by HW upon an interrupt to Base processor and can be cleared only by BASE processor.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STK_UP_IRQ_LOG</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>Reading this register Stack procesor will able to know the reason for the interrupt. This is clear only register - set by HW upon an interrupt to Stack processor and can be cleared only by Stack processor.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STK_CLK_EN</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Can be written only by base processor. Controls the enable pin of the cgcs for the clocks going to CM3 dft ctrl block and Sram.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPIN_LOCK_MODE</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Can be written only by the base processor. Decides the ram sharing mode :: handshake or Spinlock mode.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_FAULT_ADDR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Stores the last bus fault address.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_FAULT_CLR</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>write only registers on read returns 0.W Write 1 to clear the bust fault to store the new bus fault address</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RESET_CAUSE</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Reset cause value captured from the ICR_CLKRST block.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WDOG_TIMER_EVENT</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Watchdog timer event value captured from the ICR_CLKRST block</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_REQ</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>To send Dma Request to bottom die.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRAM_JUMP_OFFSET_ADDR</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>Address offset within SRAM to which CM3 should jump after reset.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SW_REG1</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>These are sw registers for topdie processor and bottom die processor to communicate. Both can set and read these registers. In case of write clash bottom die's processor wins and top die processor access is ignored.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SW_REG2</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>These are sw registers for topdie processor and bottom die processor to communicate. Both can set and read these registers. In case of write clash bottom die's processor wins and top die processor access is ignored.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FMC_SLEEP_CTL</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>By posting the request Flash can be put into low-power mode (Sleep) without powering down the Flash. Earlier (in Garnet) this was fully h/w controlled and the control for this was coming from SysCtl while entering into Cortex Deep-sleep mode. But for our device the D2D i/f doesnt support this. The Firmware has to program the register in the top-die for entering into this mode and wait for an interrupt.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MISC_CTL</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>Miscellanious control register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SW_DFT_CTL</name>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <description>DFT control and status bits</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PADN_CTL_0</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Mainly for For controlling the pads OEN pins. There are total 60 pads and hence 60 control registe i.e n value varies from 0 to 59. Here is the mapping for the pad_ctl register number and the functionality : 0 D2DPAD_DMAREQ1 1 D2DPAD_DMAREQ0 2 D2DPAD_INT2BASE 3 D2DPAD_PIOSC 4 D2DPAD_RST_N 5 D2DPAD_POR_RST_N 6 D2DPAD_HCLK 7 D2DPAD_JTAG_TDO 8 D2DPAD_JTAG_TCK 9 D2DPAD_JTAG_TMS 10 D2DPAD_JTAG_TDI 11-27 D2DPAD_FROMSTACK[D2D_FROMSTACK_SIZE -1:0] 28-56 D2DPAD_TOSTACK [D2D_TOSTACK_SIZE -1:0] 57-59 D2DPAD_SPARE [D2D_SPARE_PAD_SIZE -1:0] 0:00 ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>COMMON_REG</name>
      <baseAddress>0x400F7000</baseAddress>
      <registers>
        <register>
          <name>I2C_PROPERTIES_REGISTER</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>I2C_PROPERTIES_REGISTER</description>
          <fields>
            <field>
              <name>COMMON_REG_I2C_Properties_Register_I2C_Properties_Register</name>
              <description>[1:0] Each semaphore register is of 2 bit.  When this register is set to 2b01  Apps have access and when set to 2b10  NW have access.  Ideally both the master can modify any of this 2 bit, but assumption apps will write only 2b01 or 2b00 to this register and nw will write only 2b10 or 2b00.  Implementation is when any of the bit of this register is set, only next write allowedvis 2b00  Again assumption is one master will not write 2b00 if other is already holding the semaphore.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPI_PROPERTIES_REGISTER</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>SPI_PROPERTIES_REGISTER</description>
          <fields>
            <field>
              <name>COMMON_REG_SPI_Properties_Register_SPI_Properties_Register</name>
              <description>[1:0] Each semaphore register is of 2 bit.  When this register is set to 2b01  Apps have access and when set to 2b10  NW have access.  Ideally both the master can modify any of this 2 bit, but assumption apps will write only 2b01 or 2b00 to this register and nw will write only 2b10 or 2b00.  Implementation is when any of the bit of this register is set, only next write allowedvis 2b00  Again assumption is one master will not write 2b00 if other is already holding the semaphore.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SH_RESOURCE_INTERRUPT_ENABLE</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>APPS_SH_RESOURCE_INTERRUPT_ENABLE</description>
          <fields>
            <field>
              <name>COMMON_REG_APPS_sh_resource_Interrupt_enable_APPS_sh_resource_Interrupt_enable</name>
              <description>[3:0] Interrupt enable APPS bit 0 -> when '1' enable I2C interrupt bit 1 -> when '1' enable SPI interrupt bit 3 -> when '1' enable GPIO interrupt</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SH_RESOURCE_INTERRUPT_STATUS</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>APPS_SH_RESOURCE_INTERRUPT_STATUS</description>
          <fields>
            <field>
              <name>COMMON_REG_APPS_sh_resource_Interrupt_status_APPS_sh_resource_Interrupt_status</name>
              <description>[3:0] Interrupt enable APPS bit 0 -> when '1' enable I2C interrupt bit 1 -> when '1' enable SPI interrupt bit 3 -> when '1' enable GPIO interrupt</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_SH_RESOURCE_INTERRUPT_ENABLE</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>NWP_SH_RESOURCE_INTERRUPT_ENABLE</description>
          <fields>
            <field>
              <name>COMMON_REG_NWP_sh_resource_Interrupt_enable_NWP_sh_resource_Interrupt_enable</name>
              <description>[3:0] Interrupt enable NWP bit 0 -> when '1' enable I2C interrupt bit 1 -> when '1' enable SPI interrupt bit 3 -> when '1' enable GPIO interrupt</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_SH_RESOURCE_INTERRUPT_STATUS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>NWP_SH_RESOURCE_INTERRUPT_STATUS</description>
          <fields>
            <field>
              <name>COMMON_REG_NWP_sh_resource_Interrupt_status_NWP_sh_resource_Interrupt_status</name>
              <description>[3:0] Interrupt enable NWP bit 0 -> when '1' enable I2C interrupt bit 1 -> when '1' enable SPI interrupt bit 3 -> when '1' enable GPIO interrupt</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_CTRL_REG</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>FLASH_CTRL_REG</description>
          <fields>
            <field>
              <name>COMMON_REG_Flash_ctrl_reg_Flash_ctrl_reg</name>
              <description>[1:0] Each semaphore register is of 2 bit.  When this register is set to 2b01  Apps have access and when set to 2b10  NW have access.  Ideally both the master can modify any of this 2 bit, but assumption apps will write only 2b01 or 2b00 to this register and nw will write only 2b10 or 2b00.  Implementation is when any of the bit of this register is set, only next write allowedvis 2b00  Again assumption is one master will not write 2b00 if other is already holding the semaphore.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_MATRIX_M0_SEGMENT_ACCESS_CONFIG</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>BUS_MATRIX_M0_SEGMENT_ACCESS_CONFIG</description>
          <fields>
            <field>
              <name>COMMON_REG_Bus_matrix_M0_segment_access_config_Bus_matrix_M0_segment_access_config</name>
              <description>[17:0] Master 0 control word matrix to each segment. Tieoff. Bit value 1 indicates segment is accesable.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_MATRIX_M1_SEGMENT_ACCESS_CONFIG</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>BUS_MATRIX_M1_SEGMENT_ACCESS_CONFIG</description>
          <fields>
            <field>
              <name>COMMON_REG_Bus_matrix_M1_segment_access_config_Bus_matrix_M1_segment_access_config</name>
              <description>[17:0] Master 1 control word matrix to each segment. Tieoff. Bit value 1 indicates segment is accesable.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_MATRIX_M2_SEGMENT_ACCESS_CONFIG</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>BUS_MATRIX_M2_SEGMENT_ACCESS_CONFIG</description>
          <fields>
            <field>
              <name>COMMON_REG_Bus_matrix_M2_segment_access_config_Bus_matrix_M2_segment_access_config</name>
              <description>[17:0] Master 2 control word matrix to each segment. Tieoff. Bit value 1 indicates segment is accesable.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_MATRIX_M3_SEGMENT_ACCESS_CONFIG</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>BUS_MATRIX_M3_SEGMENT_ACCESS_CONFIG</description>
          <fields>
            <field>
              <name>COMMON_REG_Bus_matrix_M3_segment_access_config_Bus_matrix_M3_segment_access_config</name>
              <description>[17:0] Master 3 control word matrix to each segment. Tieoff. Bit value 1 indicates segment is accesable.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_MATRIX_M4_SEGMENT_ACCESS_CONFIG</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>BUS_MATRIX_M4_SEGMENT_ACCESS_CONFIG</description>
          <fields>
            <field>
              <name>COMMON_REG_Bus_matrix_M4_segment_access_config_Bus_matrix_M4_segment_access_config</name>
              <description>[17:0] Master 4 control word matrix to each segment. Tieoff. Bit value 1 indicates segment is accesable.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BUS_MATRIX_M5_SEGMENT_ACCESS_CONFIG</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>BUS_MATRIX_M5_SEGMENT_ACCESS_CONFIG</description>
          <fields>
            <field>
              <name>COMMON_REG_Bus_matrix_M5_segment_access_config_Bus_matrix_M5_segment_access_config</name>
              <description>[17:0] Master 5 control word matrix to each segment. Tieoff. Bit value 1 indicates segment is accesable.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PROPERTIES_REGISTER</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>GPIO_PROPERTIES_REGISTER</description>
          <fields>
            <field>
              <name>COMMON_REG_GPIO_properties_register_GPIO_properties_register</name>
              <description>[9:0] Shared GPIO configuration register. Bit [1:0] to configure GPIO0 Bit [3:2] to configure GPIO1 Bit [5:4] to configure GPIO2 Bit [7:6] to configure GPIO3 Bit [9:8] to configure GPIO4 each GPIO can be individully selected. When 00? GPIO is free resource. When 01? GPIO is APPS resource. When 10? GPIO is NWP resource. Writing 11 doesnt have any affect, i.e. If one write only relevant gpio semaphore and other bits are 1s, it'll not disturb the other semaphore bits. For example : Say If NW wants to take control of gpio-1, one should write 10'b11_1111_1011 and if one wants to release it write 10'b11_1111_0011.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE1</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE2</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE3</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE4</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE5</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE6</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE7</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE7</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE8</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE8</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE9</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE9</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE10</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE10</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE11</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE11</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_NW_SEMAPHORE12</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>APPS_NW_SEMAPHORE12</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SEMAPPHORE_PEND</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>APPS_SEMAPPHORE_PEND</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_SEMAPPHORE_PEND</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>NW_SEMAPPHORE_PEND</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE_STATUS</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>SEMAPHORE_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDMEM_TIM_UPDATE</name>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <description>IDMEM_TIM_UPDATE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FPGA_ROM_WR_EN</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>FPGA_ROM_WR_EN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_MASK</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>NW_INT_MASK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_MASK_SET</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>NW_INT_MASK_SET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_MASK_CLR</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>NW_INT_MASK_CLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_STS_CLR</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>NW_INT_STS_CLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_ACK</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>NW_INT_ACK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_TRIG</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>NW_INT_TRIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_STS_MASKED</name>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <description>NW_INT_STS_MASKED</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NW_INT_STS_RAW</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>NW_INT_STS_RAW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_MASK</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>APPS_INT_MASK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_MASK_SET</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>APPS_INT_MASK_SET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_MASK_CLR</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>APPS_INT_MASK_CLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_STS_CLR</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>APPS_INT_STS_CLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_ACK</name>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <description>APPS_INT_ACK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_TRIG</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>APPS_INT_TRIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_STS_MASKED</name>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <description>APPS_INT_STS_MASKED</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_INT_STS_RAW</name>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <description>APPS_INT_STS_RAW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDMEM_TIM_UPDATED</name>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <description>IDMEM_TIM_UPDATED</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_GPIO_TRIG_EN</name>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <description>APPS_GPIO_TRIG_EN</description>
          <fields>
            <field>
              <name>APPS_GPIO_TRIG_EN</name>
              <description>[4:0] APPS GPIO Trigger EN control. Bit 0: when '1' enable GPIO 0 trigger. This bit enables trigger for all GPIO 0 pins (GPIO 0 to GPIO7). Bit 1: when '1' enable GPIO 1 trigger. This bit enables trigger for all GPIO 1 pins ( GPIO8 to GPIO15). Bit 2: when '1' enable GPIO 2 trigger. This bit enables trigger for all GPIO 2 pins (GPIO16 to GPIO23). Bit 3: when '1' enable GPIO 3 trigger. This bit enables trigger for all GPIO 3 pins (GPIO24 to GPIO31). Bit 4: when '1' enable GPIO 4 trigger. This bit enables trigger for all GPIO 4 pins.(GPIO32 to GPIO39)</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EMU_DEBUG_REG</name>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <description>EMU_DEBUG_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE_STATUS2</name>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <description>SEMAPHORE_STATUS2</description>
          <fields>
            <field>
              <name>SEMPAPHORE_STATUS2</name>
              <description>[23:0] SEMAPHORE STATUS 23:22 :semaphore status of apps_nw_semaphore11 21:20 :semaphore status of apps_nw_semaphore11 19:18 :semaphore status of apps_nw_semaphore10 17:16 :semaphore status of apps_nw_semaphore9 15:14 :semaphore status of apps_nw_semaphore8 13:12 :semaphore status of apps_nw_semaphore7 11:10 :semaphore status of apps_nw_semaphore6 9:8 :semaphore status of apps_nw_semaphore5 7:6 :semaphore status of apps_nw_semaphore4 5:4 :semaphore status of apps_nw_semaphore3 3:2 :semaphore status of apps_nw_semaphore2 1:0 :semaphore status of apps_nw_semaphore1</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE_PREV_OWNER1</name>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <description>SEMAPHORE_PREV_OWNER1</description>
          <fields>
            <field>
              <name>SEMAPHORE_PREV_OWNER1</name>
              <description>[17:0] 1:0 : prvious owner of i2c_properties_reg[1:0] 3:2 : prvious owner of spi_properties_reg[1:0] 5:4 : prvious owner of gpio_properties_reg[1:0] 9:8 : prvious owner of gpio_properties_reg[3:2] 11:10 : prvious owner of gpio_properties_reg[5:4] 13:12 : prvious owner of gpio_properties_reg[7:6] 15:14 : prvious owner of gpio_properties_reg[9:8] 17:16 : prvious owner of flash_control_reg[1:0]</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE_PREV_OWNER2</name>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <description>SEMAPHORE_PREV_OWNER2</description>
          <fields>
            <field>
              <name>SEMAPHORE_PREV_OWNER2</name>
              <description>[23:0] 1:0 : previous owner of apps_nw_semaphore1_reg[1:0] 3:2 : previous owner of apps_nw_semaphore2_reg[1:0] 5:4 : previous owner of apps_nw_semaphore3_reg[1:0] 7:6 : previous owner of apps_nw_semaphore4_reg[1:0] 9:8 : previous owner of apps_nw_semaphore5_reg[1:0] 11:10 : previous owner of apps_nw_semaphore6_reg[1:0] 13:12 : previous owner of apps_nw_semaphore7_reg[1:0] 15:14 : previous owner of apps_nw_semaphore8_reg[1:0] 17:16 : previous owner of apps_nw_semaphore9_reg[1:0] 19:18 : previous owner of apps_nw_semaphore10_reg[1:0] 21:20 : previous owner of apps_nw_semaphore11_reg[1:0] 23:22 : previous owner of apps_nw_semaphore12_reg[1:0]</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASH_CONTROL</name>
      <baseAddress>0x400FD000</baseAddress>
      <registers>
        <register>
          <name>FMA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Flash Memory Address (FMA) offset 0x000 During a write operation this register contains a 4-byte-aligned address and specifies where the data is written. During erase operations this register contains a 1 KB-aligned CPU byte address and specifies which block is erased. Note that the alignment requirements must be met by software or the results of the operation are unpredictable.</description>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>[17:0] Address Offset Address offset in Flash memory where operation is performed except for nonvolatile registers</description>
              <bitWidth>18</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FMD</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Flash Memory Data (FMD) offset 0x004 This register contains the data to be written during the programming cycle or read during the read cycle. Note that the contents of this register are undefined for a read access of an execute-only block. This register is not used during erase cycles.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FMC</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Flash Memory Control (FMC) offset 0x008 When this register is written the Flash memory controller initiates the appropriate access cycle for the location specified by the Flash Memory Address (FMA) register . If the access is a write access the data contained in the Flash Memory Data (FMD) register is written to the specified address. This register must be the final register written and initiates the memory operation. The four control bits in the lower byte of this register are used to initiate memory operations.</description>
          <fields>
            <field>
              <name>WRKEY</name>
              <description>[31:16] Flash Memory Write Key This field contains a write key which is used to minimize the incidence of accidental Flash memory writes. The value 0xA442 must be written into this field for a Flash memory write to occur. Writes to the FMC register without this WRKEY value are ignored. A read of this field returns the value 0.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FCRIS</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>Flash Controller Raw Interrupt Status (FCRIS) offset 0x00C This register indicates that the Flash memory controller has an interrupt condition. An interrupt is sent to the interrupt controller only if the corresponding FCIM register bit is set.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FCIM</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Flash Controller Interrupt Mask (FCIM) offset 0x010 This register controls whether the Flash memory controller generates interrupts to the controller.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FCMISC</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Flash Controller Masked Interrupt Status and Clear (FCMISC) offset 0x014 This register provides two functions. First it reports the cause of an interrupt by indicating which interrupt source or sources are signalling the interrupt. Second it serves as the method to clear the interrupt reporting.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FMC2</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Flash Memory Control 2 (FMC2) offset 0x020 When this register is written the Flash memory controller initiates the appropriate access cycle for the location specified by the Flash Memory Address (FMA) register . If the access is a write access the data contained in the Flash Write Buffer (FWB) registers is written. This register must be the final register written as it initiates the memory operation.</description>
          <fields>
            <field>
              <name>WRKEY</name>
              <description>[31:16] Flash Memory Write Key This field contains a write key which is used to minimize the incidence of accidental Flash memory writes. The value 0xA442 must be written into this field for a write to occur. Writes to the FMC2 register without this WRKEY value are ignored. A read of this field returns the value 0.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWBVAL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer Valid (FWBVAL) offset 0x030 This register provides a bitwise status of which FWBn registers have been written by the processor since the last write of the Flash memory write buffer. The entries with a 1 are written on the next write of the Flash memory write buffer. This register is cleared after the write operation by hardware. A protection violation on the write operation also clears this status. Software can program the same 32 words to various Flash memory locations by setting the FWB[n] bits after they are cleared by the write operation. The next write operation then uses the same data as the previous one. In addition if a FWBn register change should not be written to Flash memory software can clear the corresponding FWB[n] bit to preserve the existing data when the next write operation occurs.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB1</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB2</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB3</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB4</name>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB5</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB6</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB7</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB8</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB9</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB10</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB11</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB12</name>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB13</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB14</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB15</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB16</name>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB17</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB18</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB19</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB20</name>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB21</name>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB22</name>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB23</name>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB24</name>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB25</name>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB26</name>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB27</name>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB28</name>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB29</name>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB30</name>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB31</name>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWB32</name>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <description>Flash Write Buffer n (FWBn) offset 0x100 - 0x17C These 32 registers hold the contents of the data to be written into the Flash memory on a buffered Flash memory write operation. The offset selects one of the 32-bit registers. Only FWBn registers that have been updated since the preceding buffered Flash memory write operation are written into the Flash memory so it is not necessary to write the entire bank of registers in order to write 1 or 2 words. The FWBn registers are written into the Flash memory with the FWB0 register corresponding to the address contained in FMA. FWB1 is written to the address FMA+0x4 etc. Note that only data bits that are 0 result in the Flash memory being modified. A data bit that is 1 leaves the content of the Flash memory bit at its previous value.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSIZE</name>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <description>Flash Size (FSIZE) offset 0xFC0 This register indicates the size of the on-chip Flash memory. Important: This register should be used to determine the size of the Flash memory that is implemented on this microcontroller. However to support legacy software the DC0 register is available. A read of the DC0 register correctly identifies legacy memory sizes. Software must use the FSIZE register for memory sizes that are not listed in the DC0 register description.</description>
          <fields>
            <field>
              <name>SIZE</name>
              <description>[15:0] Flash Size Indicates the size of the on-chip Flash memory. Value Description 0x0003 8 KB of Flash 0x0007 16 KB of Flash 0x000F 32 KB of Flash 0x001F 64 KB of Flash 0x002F 96 KB of Flash 0x003F 128 KB of Flash 0x005F 192 KB of Flash 0x007F 256 KB of Flash</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSIZE</name>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <description>SRAM Size (SSIZE) offset 0xFC4 This register indicates the size of the on-chip SRAM. Important: This register should be used to determine the size of the SRAM that is implemented on this microcontroller. However to support legacy software the DC0 register is available. A read of the DC0 register correctly identifies legacy memory sizes. Software must use the SSIZE register for memory sizes that are not listed in the DC0 register description. ****************************************************************************</description>
          <fields>
            <field>
              <name>SRAM_SIZE</name>
              <description>[15:0] SRAM Size Indicates the size of the on-chip SRAM. Value Description 0x0007 2 KB of SRAM 0x000F 4 KB of SRAM 0x0017 6 KB of SRAM 0x001F 8 KB of SRAM 0x002F 12 KB of SRAM 0x003F 16 KB of SRAM 0x004F 20 KB of SRAM 0x005F 24 KB of SRAM 0x007F 32 KB of SRAM</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYSTEM_CONTROL</name>
      <baseAddress>0x400FE000</baseAddress>
      <registers>
        <register>
          <name>HL_REV</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>IP Revision Identifier (X.Y.R) Used by software to track features bugs and compatibility</description>
          <fields>
            <field>
              <name>SCHEME</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>FUNC</name>
              <description>[27:16] Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>R_RTL</name>
              <description>[15:11] RTL Version (R) maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>X_MAJOR</name>
              <description>[10:8] Major Revision (X) maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUSTOM</name>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Y_MINOR</name>
              <description>[5:0] Minor Revision (Y) maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R S X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HL_HWINFO</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Information about the IP module's hardware configuration i.e. typically the module's HDL generics (if any). Actual field format and encoding is up to the module's designer to decide.</description>
          <fields>
            <field>
              <name>MEM_SIZE</name>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HL_SYSCONFIG</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Clock management configuration</description>
          <fields>
            <field>
              <name>STANDBYMODE</name>
              <description>[5:4] Configuration of the local initiator state management mode. By definition initiator may generate read/write transaction as long as it is out of STANDBY state. 0x0 Force-standby mode: local initiator is unconditionally placed in standby state.Backup mode for debug only. 0x1 No-standby mode: local initiator is unconditionally placed out of standby state.Backup mode for debug only. 0x2 Smart-standby mode: local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator.IP module shall not generate (initiator-related) wakeup events. 0x3 &amp;quot;Smart-Standby wakeup-capable mode: local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator. IP module may generate (master-related) wakeup events when in standby state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;mwakeup&amp;quot;&amp;quot; output is implemented.&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>IDLEMODE</name>
              <description>[3:2] Configuration of the local target state management mode. By definition target can handle read/write transaction as long as it is out of IDLE state. 0x0 Force-idle mode: local target's idle state follows (acknowledges) the system's idle requests unconditionally i.e. regardless of the IP module's internal requirements.Backup mode for debug only. 0x1 No-idle mode: local target never enters idle state.Backup mode for debug only. 0x2 Smart-idle mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module shall not generate (IRQ- or DMA-request-related) wakeup events. 0x3 &amp;quot;Smart-idle wakeup-capable mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module may generate (IRQ- or DMA-request-related) wakeup events when in idle state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;swakeup&amp;quot;&amp;quot; output(s) is (are) implemented.&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCONFIG</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>System Configuration Register This register allows controlling various parameters of the OCP interface.</description>
          <fields>
            <field>
              <name>STANDBYMODE</name>
              <description>[13:12] Master interface power Management standby/wait control. The bit field is only useful when generic parameter MADMA_EN (Master ADMA enable) is set as active otherwise it is a read only register read a '0'. 0x0 Force-standby. Mstandby is forced unconditionnaly. 0x1 No-standby. Mstandby is never asserted. 0x2 Smart-standby mode: local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator.IP module shall not generate (initiator-related) wakeup events. 0x3 Smart-Standby wakeup-capable mode: &amp;quot;local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator. IP module may generate (master-related) wakeup events when in standby state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;mwakeup&amp;quot;&amp;quot; output is implemented.&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CLOCKACTIVITY</name>
              <description>[9:8] Clocks activity during wake up mode period. Bit8: OCP interface clock Bit9: Functional clock 0x0 OCP and Functional clock may be switched off. 0x1 OCP clock is maintained. Functional clock may be switched-off. 0x2 Functional clock is maintained. OCP clock may be switched-off. 0x3 OCP and Functional clocks are maintained.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SIDLEMODE</name>
              <description>[4:3] Power management 0x0 If an idle request is detected the MMCHS acknowledges it unconditionally and goes in Inactive mode. Interrupt and DMA requests are unconditionally de-asserted. 0x1 If an idle request is detected the request is ignored and the module keeps on behaving normally. 0x2 Smart-idle mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module shall not generate (IRQ- or DMA-request-related) wakeup events. 0x3 Smart-idle wakeup-capable mode: &amp;quot;local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module may generate (IRQ- or DMA-request-related) wakeup events when in idle state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;swakeup&amp;quot;&amp;quot; output(s) is (are) implemented.&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSSTATUS</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>System Status Register This register provides status information about the module excluding the interrupt status information</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSRE</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>Card status response error This register enables the host controller to detect card status errors of response type R1 R1b for all cards and of R5 R5b and R6 response for cards types SD or SDIO. When a bit MMCHS_CSRE[i] is set to 1 if the corresponding bit at the same position in the response MMCHS_RSP0[i] is set to 1 the host controller indicates a card error (MMCHS_STAT[CERR]) interrupt status to avoid the host driver reading the response register (MMCHS_RSP0). Note: No automatic card error detection for autoCMD12 is implemented; the host system has to check autoCMD12 response register (MMCHS_RESP76) for possible card errors.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSTEST</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>System Test register This register is used to control the signals that connect to I/O pins when the module is configured in system test (SYSTEST) mode for boundary connectivity verification. Note: In SYSTEST mode a write into MMCHS_CMD register will not start a transfer. The buffer behaves as a stack accessible only by the local host (push and pop operations). In this mode the Transfer Block Size (MMCHS_BLK[BLEN]) and the Blocks count for current transfer (MMCHS_BLK[NBLK]) are needed to generate a Buffer write ready interrupt (MMCHS_STAT[BWR]) or a Buffer read ready interrupt (MMCHS_STAT[BRR]) and DMA requests if enabled.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CON</name>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <description>Configuration register This register is used: - to select the functional mode or the SYSTEST mode for any card. - to send an initialization sequence to any card. - to enable the detection on DAT[1] of a card interrupt for SDIO cards only. and also to configure : - specific data and command transfers for MMC cards only. - the parameters related to the card detect and write protect input signals.</description>
          <fields>
            <field>
              <name>DVAL</name>
              <description>[10:9] Debounce filter value All cards This register is used to define a debounce period to filter the card detect input signal (SDCD). The usage of the card detect input signal (SDCD) is optional and depends on the system integration and the type of the connector housing that accommodates the card. 0x0 33 us debounce period 0x1 231 us debounce period 0x2 1 ms debounce period 0x3 84 ms debounce period</description>
              <bitWidth>2</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PWCNT</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>Power counter register This register is used to program a mmc counter to delay command transfers after activating the PAD power this value depends on PAD characteristics and voltage.</description>
          <fields>
            <field>
              <name>PWRCNT</name>
              <description>[15:0] Power counter register. This register is used to introduce a delay between the PAD ACTIVE pin assertion and the command issued. 0x0000 No additional delay added 0x0001 TCF delay (card clock period) 0x0002 TCF x 2 delay (card clock period) 0xFFFE TCF x 65534 delay (card clock period) 0xFFFF TCF x 65535 delay (card clock period)</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BLK</name>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <description>Transfer Length Configuration register MMCHS_BLK[BLEN] is the block size register. MMCHS_BLK[NBLK] is the block count register. This register shall be used for any card.</description>
          <fields>
            <field>
              <name>NBLK</name>
              <description>[31:16] Blocks count for current transfer This register is enabled when Block count Enable (MMCHS_CMD[BCE]) is set to 1 and is valid only for multiple block transfers. Setting the block count to 0 results no data blocks being transferred. Note: The host controller decrements the block count after each block transfer and stops when the count reaches zero. This register can be accessed only if no transaction is executing (i.e after a transaction has stopped). Read operations during transfers may return an invalid value and write operation will be ignored. In suspend context the number of blocks yet to be transferred can be determined by reading this register. When restoring transfer context prior to issuing a Resume command The local host shall restore the previously saved block count. 0x0000 Stop count 0x0001 1 block 0x0002 2 blocks 0xFFFF 65535 blocks</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BLEN</name>
              <description>[11:0] Transfer Block Size. This register specifies the block size for block data transfers. Read operations during transfers may return an invalid value and write operations are ignored. When a CMD12 command is issued to stop the transfer a read of the BLEN field after transfer completion (MMCHS_STAT[TC] set to 1) will not return the true byte number of data length while the stop occurs but the value written in this register before transfer is launched. 0x000 No data transfer 0x001 1 byte block length 0x002 2 bytes block length 0x003 3 bytes block length 0x1FF 511 bytes block length 0x200 512 bytes block length 0x7FF 2047 bytes block length 0x800 2048 bytes block length</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ARG</name>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <description>Command argument Register This register contains command argument specified as bit 39-8 of Command-Format These registers must be initialized prior to sending the command itself to the card (write action into the register MMCHS_CMD register). Only exception is for a command index specifying stuff bits in arguments making a write unnecessary.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CMD</name>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <description>Command and transfer mode register MMCHS_CMD[31:16] = the command register MMCHS_CMD[15:0] = the transfer mode. This register configures the data and command transfers. A write into the most significant byte send the command. A write into MMCHS_CMD[15:0] registers during data transfer has no effect. This register shall be used for any card. Note: In SYSTEST mode a write into MMCHS_CMD register will not start a transfer.</description>
          <fields>
            <field>
              <name>INDX</name>
              <description>[29:24] Command index Binary encoded value from 0 to 63 specifying the command number send to card 0x00 CMD0 or ACMD0 0x01 CMD1 or ACMD1 0x02 CMD2 or ACMD2 0x03 CMD3 or ACMD3 0x04 CMD4 or ACMD4 0x05 CMD5 or ACMD5 0x06 CMD6 or ACMD6 0x07 CMD7 or ACMD7 0x08 CMD8 or ACMD8 0x09 CMD9 or ACMD9 0x0A CMD10 or ACMD10 0x0B CMD11 or ACMD11 0x0C CMD12 or ACMD12 0x0D CMD13 or ACMD13 0x0E CMD14 or ACMD14 0x0F CMD15 or ACMD15 0x10 CMD16 or ACMD16 0x11 CMD17 or ACMD17 0x12 CMD18 or ACMD18 0x13 CMD19 or ACMD19 0x14 CMD20 or ACMD20 0x15 CMD21 or ACMD21 0x16 CMD22 or ACMD22 0x17 CMD23 or ACMD23 0x18 CMD24 or ACMD24 0x19 CMD25 or ACMD25 0x1A CMD26 or ACMD26 0x1B CMD27 or ACMD27 0x1C CMD28 or ACMD28 0x1D CMD29 or ACMD29 0x1E CMD30 or ACMD30 0x1F CMD31 or ACMD31 0x20 CMD32 or ACMD32 0x21 CMD33 or ACMD33 0x22 CMD34 or ACMD34 0x23 CMD35 or ACMD35 0x24 CMD36 or ACMD36 0x25 CMD37 or ACMD37 0x26 CMD38 or ACMD38 0x27 CMD39 or ACMD39 0x28 CMD40 or ACMD40 0x29 CMD41 or ACMD41 0x2A CMD42 or ACMD42 0x2B CMD43 or ACMD43 0x2C CMD44 or ACMD44 0x2D CMD45 or ACMD45 0x2E CMD46 or ACMD46 0x2F CMD47 or ACMD47 0x30 CMD48 or ACMD48 0x31 CMD49 or ACMD49 0x32 CMD50 or ACMD50 0x33 CMD51 or ACMD51 0x34 CMD52 or ACMD52 0x35 CMD53 or ACMD53 0x36 CMD54 or ACMD54 0x37 CMD55 or ACMD55 0x38 CMD56 or ACMD56 0x39 CMD57 or ACMD57 0x3A CMD58 or ACMD58 0x3B CMD59 or ACMD59 0x3C CMD60 or ACMD60 0x3D CMD61 or ACMD61 0x3E CMD62 or ACMD62 0x3F CMD63 or ACMD63</description>
              <bitWidth>6</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CMD_TYPE</name>
              <description>[23:22] Command type This register specifies three types of special command: Suspend Resume and Abort. These bits shall be set to 00b for all other commands. 0x0 Others Commands 0x1 &amp;quot;CMD52 for writing &amp;quot;&amp;quot;Bus Suspend&amp;quot;&amp;quot; in CCCR&amp;quot; 0x2 &amp;quot;CMD52 for writing &amp;quot;&amp;quot;Function Select&amp;quot;&amp;quot; in CCCR&amp;quot; 0x3 &amp;quot;Abort command CMD12 CMD52 for writing &amp;quot;&amp;quot; I/O Abort&amp;quot;&amp;quot; in CCCR&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>RSP_TYPE</name>
              <description>[17:16] Response type This bits defines the response type of the command 0x0 No response 0x1 Response Length 136 bits 0x2 Response Length 48 bits 0x3 Response Length 48 bits with busy after response</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSP10</name>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <description>Command response[31:0] Register This 32-bit register holds bits positions [31:0] of command response type R1/R1b/R2/R3/R4/R5/R5b/R6</description>
          <fields>
            <field>
              <name>RSP1</name>
              <description>[31:16] Command Response [31:16]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RSP0</name>
              <description>[15:0] Command Response [15:0]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSP32</name>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <description>Command response[63:32] Register This 32-bit register holds bits positions [63:32] of command response type R2</description>
          <fields>
            <field>
              <name>RSP3</name>
              <description>[31:16] Command Response [63:48]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RSP2</name>
              <description>[15:0] Command Response [47:32]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSP54</name>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <description>Command response[95:64] Register This 32-bit register holds bits positions [95:64] of command response type R2</description>
          <fields>
            <field>
              <name>RSP5</name>
              <description>[31:16] Command Response [95:80]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RSP4</name>
              <description>[15:0] Command Response [79:64]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSP76</name>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <description>Command response[127:96] Register This 32-bit register holds bits positions [127:96] of command response type R2</description>
          <fields>
            <field>
              <name>RSP7</name>
              <description>[31:16] Command Response [127:112]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RSP6</name>
              <description>[15:0] Command Response [111:96]</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA</name>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <description>Data Register This register is the 32-bit entry point of the buffer for read or write data transfers. The buffer size is 32bits x256(1024 bytes). Bytes within a word are stored and read in little endian format. This buffer can be used as two 512 byte buffers to transfer data efficiently without reducing the throughput. Sequential and contiguous access is necessary to increment the pointer correctly. Random or skipped access is not allowed. In little endian if the local host accesses this register byte-wise or 16bit-wise the least significant byte (bits [7:0]) must always be written/read first. The update of the buffer address is done on the most significant byte write for full 32-bit DATA register or on the most significant byte of the last word of block transfer. Example 1: Byte or 16-bit access Mbyteen[3:0]=0001 (1-byte) => Mbyteen[3:0]=0010 (1-byte) => Mbyteen[3:0]=1100 (2-bytes) OK Mbyteen[3:0]=0001 (1-byte) => Mbyteen[3:0]=0010 (1-byte) => Mbyteen[3:0]=0100 (1-byte) OK Mbyteen[3:0]=0001 (1-byte) => Mbyteen[3:0]=0010 (1-byte) => Mbyteen[3:0]=1000 (1-byte) Bad</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PSTATE</name>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <description>Present state register The Host can get status of the Host Controller from this 32-bit read only register.</description>
          <fields>
            <field>
              <name>DLEV</name>
              <description>[23:20] DAT[3:0] line signal level DAT[3] => bit 23 DAT[2] => bit 22 DAT[1] => bit 21 DAT[0] => bit 20 This status is used to check DAT line level to recover from errors and for debugging. This is especially useful in detecting the busy signal level from DAT[0]. The value of these registers after reset depends on the DAT lines level at that time.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HCTL</name>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <description>Control register This register defines the host controls to set power wakeup and transfer parameters. MMCHS_HCTL[31:24] = Wakeup control MMCHS_HCTL[23:16] = Block gap control MMCHS_HCTL[15:8] = Power control MMCHS_HCTL[7:0] = Host control</description>
          <fields>
            <field>
              <name>SDVS</name>
              <description>[11:9] SD bus voltage select All cards. The host driver should set to these bits to select the voltage level for the card according to the voltage supported by the system (MMCHS_CAPA[VS18VS30VS33]) before starting a transfer. 0x5 1.8V (Typical) 0x6 3.0V (Typical) 0x7 3.3V (Typical)</description>
              <bitWidth>3</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DMAS</name>
              <description>[4:3] DMA Select Mode: One of supported DMA modes can be selected. The host driver shall check support of DMA modes by referring the Capabilities register. Use of selected DMA is determined by DMA Enable of the Transfer Mode register. This register is only meaningful when MADMA_EN is set to 1. When MADMA_EN is set to 0 the bit field is read only and returned value is 0. 0x0 Reserved 0x1 Reserved 0x2 32-bit Address ADMA2 is selected 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCTL</name>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <description>SD system control register This register defines the system controls to set software resets clock frequency management and data timeout. MMCHS_SYSCTL[31:24] = Software resets MMCHS_SYSCTL[23:16] = Timeout control MMCHS_SYSCTL[15:0] = Clock control</description>
          <fields>
            <field>
              <name>DTO</name>
              <description>[19:16] Data timeout counter value and busy timeout. This value determines the interval by which DAT lines timeouts are detected. The host driver needs to set this bitfield based on - the maximum read access time (NAC) (Refer to the SD Specification Part1 Physical Layer) - the data read access time values (TAAC and NSAC) in the card specific data register (CSD) of the card - the timeout clock base frequency (MMCHS_CAPA[TCF]). If the card does not respond within the specified number of cycles a data timeout error occurs (MMCHS_STA[DTO]). The MMCHS_SYSCTL[DTO] register is also used to check busy duration to generate busy timeout for commands with busy response or for busy programming during a write command. Timeout on CRC status is generated if no CRC token is present after a block write. 0x0 TCF x 2^13 0x1 TCF x 2^14 0xE TCF x 2^27 0xF Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[15:6] Clock frequency select These bits define the ratio between a reference clock frequency (system dependant) and the output clock frequency on the CLK pin of either the memory card (MMC SD or SDIO). 0x000 Clock Ref bypass 0x001 Clock Ref bypass 0x002 Clock Ref / 2 0x003 Clock Ref / 3 0x3FF Clock Ref / 1023</description>
              <bitWidth>10</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STAT</name>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <description>Interrupt status register The interrupt status regroups all the status of the module internal events that can generate an interrupt. MMCHS_STAT[31:16] = Error Interrupt Status MMCHS_STAT[15:0] = Normal Interrupt Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IE</name>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <description>Interrupt SD enable register This register allows to enable/disable the module to set status bits on an event-by-event basis. MMCHS_IE[31:16] = Error Interrupt Status Enable MMCHS_IE[15:0] = Normal Interrupt Status Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ISE</name>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <description>Interrupt signal enable register This register allows to enable/disable the module internal sources of status on an event-by-event basis. MMCHS_ISE[31:16] = Error Interrupt Signal Enable MMCHS_ISE[15:0] = Normal Interrupt Signal Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AC12</name>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <description>Auto CMD12 Error Status Register The host driver may determine which of the errors cases related to Auto CMD12 has occurred by checking this MMCHS_AC12 register when an Auto CMD12 Error interrupt occurs. This register is valid only when Auto CMD12 is enabled (MMCHS_CMD[ACEN]) and Auto CMD12Error (MMCHS_STAT[ACE]) is set to 1. Note: These bits are automatically reset when starting a new adtc command with data.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CAPA</name>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <description>Capabilities register This register lists the capabilities of the MMC/SD/SDIO host controller.</description>
          <fields>
            <field>
              <name>MBL</name>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BCF</name>
              <bitWidth>6</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TCF</name>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CUR_CAPA</name>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <description>Maximum current capabilities Register This register indicates the maximum current capability for each voltage. The value is meaningful if the voltage support is set in the capabilities register (MMCHS_CAPA). Initialization of this register (via a write access to this register) depends on the system capabilities. The host driver shall not modify this register after the initilaization. This register is only reinitialized by a hard reset (via RESETN signal)</description>
          <fields>
            <field>
              <name>CUR_1V8</name>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CUR_3V0</name>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUR_3V3</name>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FE</name>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <description>Force Event Register for Error Interrupt status The force Event Register is not a physically implemented register. Rather it is an address at which the Error Interrupt Status register can be written. The effect of a write to this address will be reflected in the Error Interrupt Status Register if corresponding bit of the Error Interrupt Status Enable Register is set.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADMAES</name>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <description>ADMA Error Status Register When ADMA Error Interrupt is occurred the ADMA Error States field in this register holds the ADMA state and the ADMA System Address Register holds the address around the error descriptor. For recovering the error the Host Driver requires the ADMA state to identify the error descriptor address as follows: ST_STOP: Previous location set in the ADMA System Address register is the error descriptor address ST_FDS: Current location set in the ADMA System Address register is the error descriptor address ST_CADR: This sate is never set because do not generate ADMA error in this state. ST_TFR: Previous location set in the ADMA System Address register is the error descriptor address In case of write operation the Host Driver should use ACMD22 to get the number of written block rather than using this information since unwritten data may exist in the Host Controller. The Host Controller generates the ADMA Error Interrupt when it detects invalid descriptor data (Valid=0) at the ST_FDS state. In this case ADMA Error State indicates that an error occurs at ST_FDS state. The Host Driver may find that the Valid bit is not set in the error descriptor.</description>
          <fields>
            <field>
              <name>AES</name>
              <description>[1:0] ADMA Error State his field indicates the state of ADMA when error is occurred during ADMA data transfer. &amp;quot;This field never indicates &amp;quot;&amp;quot;10&amp;quot;&amp;quot; because ADMA never stops in this state.&amp;quot; 0x0 ST_STOP (Stop DMA)Contents of SYS_SDR register 0x1 ST_STOP (Stop DMA)Points the error descriptor 0x2 Never set this state(Not used) 0x3 ST_TFR (Transfer Data)Points the next of the error descriptor</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADMASAL</name>
          <addressOffset>0x258</addressOffset>
          <size>32</size>
          <description>ADMA System address Low bits</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REV</name>
          <addressOffset>0x2FC</addressOffset>
          <size>32</size>
          <description>Versions Register This register contains the hard coded RTL vendor revision number the version number of SD specification compliancy and a slot status bit. MMCHS_REV[31:16] = Host controller version MMCHS_REV[15:0] = Slot Interrupt Status ****************************************************************************</description>
          <fields>
            <field>
              <name>VREV</name>
              <description>[31:24] Vendor Version Number: IP revision [7:4] Major revision [3:0] Minor revision Examples: 0x10 for 1.0 0x21 for 2.1</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SREV</name>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UDMA</name>
      <baseAddress>0x400FF000</baseAddress>
      <registers>
        <register>
          <name>STAT</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>STAT</description>
          <fields>
            <field>
              <name>DMACHANS</name>
              <description>[20:16] Available uDMA Channels Minus 1</description>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>STATE</name>
              <description>[7:4] Control State Machine Status 0x00000090 : UDMA_STAT_STATE_DONE : Done 0x00000000 : UDMA_STAT_STATE_IDLE : Idle 0x00000010 : UDMA_STAT_STATE_RD_CTRL : Reading channel controller data 0x00000030 : UDMA_STAT_STATE_RD_DSTENDP : Reading destination end pointer 0x00000040 : UDMA_STAT_STATE_RD_SRCDAT : Reading source data 0x00000020 : UDMA_STAT_STATE_RD_SRCENDP : Reading source end pointer 0x00000080 : UDMA_STAT_STATE_STALL : Stalled 0x000000A0 : UDMA_STAT_STATE_UNDEF : Undefined 0x00000060 : UDMA_STAT_STATE_WAIT : Waiting for uDMA request to clear 0x00000070 : UDMA_STAT_STATE_WR_CTRL : Writing channel controller data 0x00000050 : UDMA_STAT_STATE_WR_DSTDAT : Writing destination data</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CFG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>CFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTLBASE</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>CTLBASE</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:10] Channel Control Base Address</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALTBASE</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>ALTBASE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WAITSTAT</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>WAITSTAT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SWREQ</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>SWREQ</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USEBURSTSET</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>USEBURSTSET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USEBURSTCLR</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>USEBURSTCLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REQMASKSET</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>REQMASKSET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REQMASKCLR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>REQMASKCLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ENASET</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>ENASET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ENACLR</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>ENACLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALTSET</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>ALTSET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALTCLR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>ALTCLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRIOSET</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>PRIOSET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRIOCLR</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>PRIOCLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ERRCLR</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>ERRCLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHASGN</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>CHASGN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHIS</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>CHIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP0</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>CHMAP0</description>
          <fields>
            <field>
              <name>CH7SEL</name>
              <description>[31:28] uDMA Channel 7 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH6SEL</name>
              <description>[27:24] uDMA Channel 6 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH5SEL</name>
              <description>[23:20] uDMA Channel 5 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH4SEL</name>
              <description>[19:16] uDMA Channel 4 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH3SEL</name>
              <description>[15:12] uDMA Channel 3 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH2SEL</name>
              <description>[11:8] uDMA Channel 2 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH1SEL</name>
              <description>[7:4] uDMA Channel 1 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH0SEL</name>
              <description>[3:0] uDMA Channel 0 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP1</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>CHMAP1</description>
          <fields>
            <field>
              <name>CH15SEL</name>
              <description>[31:28] uDMA Channel 15 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH14SEL</name>
              <description>[27:24] uDMA Channel 14 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH13SEL</name>
              <description>[23:20] uDMA Channel 13 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH12SEL</name>
              <description>[19:16] uDMA Channel 12 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH11SEL</name>
              <description>[15:12] uDMA Channel 11 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH10SEL</name>
              <description>[11:8] uDMA Channel 10 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH9SEL</name>
              <description>[7:4] uDMA Channel 9 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH8SEL</name>
              <description>[3:0] uDMA Channel 8 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP2</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>CHMAP2</description>
          <fields>
            <field>
              <name>CH23SEL</name>
              <description>[31:28] uDMA Channel 23 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH22SEL</name>
              <description>[27:24] uDMA Channel 22 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH21SEL</name>
              <description>[23:20] uDMA Channel 21 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH20SEL</name>
              <description>[19:16] uDMA Channel 20 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH19SEL</name>
              <description>[15:12] uDMA Channel 19 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH18SEL</name>
              <description>[11:8] uDMA Channel 18 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH17SEL</name>
              <description>[7:4] uDMA Channel 17 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH16SEL</name>
              <description>[3:0] uDMA Channel 16 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP3</name>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <description>CHMAP3</description>
          <fields>
            <field>
              <name>CH31SEL</name>
              <description>[31:28] uDMA Channel 31 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH30SEL</name>
              <description>[27:24] uDMA Channel 30 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH29SEL</name>
              <description>[23:20] uDMA Channel 29 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH28SEL</name>
              <description>[19:16] uDMA Channel 28 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH27SEL</name>
              <description>[15:12] uDMA Channel 27 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH26SEL</name>
              <description>[11:8] uDMA Channel 26 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH25SEL</name>
              <description>[7:4] uDMA Channel 25 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH24SEL</name>
              <description>[3:0] uDMA Channel 24 Source Select</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PV</name>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <description>PV</description>
          <fields>
            <field>
              <name>MAJOR</name>
              <description>[15:8] Major Revision</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MINOR</name>
              <description>[7:0] Minor Revision</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAMERA</name>
      <baseAddress>0x44018000</baseAddress>
      <registers>
        <register>
          <name>CC_REVISION</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>This register contains the IP revision code ( Parallel Mode)</description>
          <fields>
            <field>
              <name>REV</name>
              <description>[7:0] IP revision [7:4] Major revision [3:0] Minor revision Examples: 0x10 for 1.0 0x21 for 2.1</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_SYSCONFIG</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>This register controls the various parameters of the OCP interface (CCP and Parallel Mode)</description>
          <fields>
            <field>
              <name>S_IDLE_MODE</name>
              <description>[4:3] Slave interface power management req/ack control &amp;quot;&amp;quot;&amp;quot;00&amp;quot;&amp;quot; Force-idle. An idle request is acknoledged unconditionally&amp;quot; &amp;quot;&amp;quot;&amp;quot;01&amp;quot;&amp;quot; No-idle. An idle request is never acknowledged&amp;quot; &amp;quot;&amp;quot;&amp;quot;10&amp;quot;&amp;quot; reserved (Smart-idle not implemented)&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_SYSSTATUS</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>This register provides status information about the module excluding the interrupt status information (CCP and Parallel Mode)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_IRQSTATUS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>The interrupt status regroups all the status of the module internal events that can generate an interrupt (CCP &amp; Parallel Mode)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_IRQENABLE</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>The interrupt enable register allows to enable/disable the module internal sources of interrupt on an event-by-event basis (CCP &amp; Parallel Mode)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_CTRL</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>This register controls the various parameters of the Camera Core block (CCP &amp; Parallel Mode)</description>
          <fields>
            <field>
              <name>PAR_MODE</name>
              <description>[3:1] Sets the Protocol Mode of the Camera Core module in parallel mode (when CCP_MODE = 0) &amp;quot;&amp;quot;&amp;quot;000&amp;quot;&amp;quot; Parallel NOBT 8-bit&amp;quot; &amp;quot;&amp;quot;&amp;quot;001&amp;quot;&amp;quot; Parallel NOBT 10-bit&amp;quot; &amp;quot;&amp;quot;&amp;quot;010&amp;quot;&amp;quot; Parallel NOBT 12-bit&amp;quot; &amp;quot;&amp;quot;&amp;quot;011&amp;quot;&amp;quot; reserved&amp;quot; &amp;quot;&amp;quot;&amp;quot;100&amp;quot;&amp;quot; Parallet BT 8-bit&amp;quot; &amp;quot;&amp;quot;&amp;quot;101&amp;quot;&amp;quot; Parallel BT 10-bit&amp;quot; &amp;quot;&amp;quot;&amp;quot;110&amp;quot;&amp;quot; reserved&amp;quot; &amp;quot;&amp;quot;&amp;quot;111&amp;quot;&amp;quot; FIFO test mode. Refer to Table 12 - FIFO Write and Read access&amp;quot;</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_CTRL_DMA</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>This register controls the DMA interface of the Camera Core block (CCP &amp; Parallel Mode)</description>
          <fields>
            <field>
              <name>FIFO_THRESHOLD</name>
              <description>[6:0] Sets the threshold of the FIFO the assertion of the dmarequest line takes place when the threshold is reached. &amp;quot;&amp;quot;&amp;quot;0000000&amp;quot;&amp;quot; threshold set to 1&amp;quot; &amp;quot;&amp;quot;&amp;quot;0000001&amp;quot;&amp;quot; threshold set to 2&amp;quot;  &amp;quot;&amp;quot;&amp;quot;1111111&amp;quot;&amp;quot; threshold set to 128&amp;quot;</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_CTRL_XCLK</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>This register control the value of the clock divisor used to generate the external clock (Parallel Mode)</description>
          <fields>
            <field>
              <name>XCLK_DIV</name>
              <description>[4:0] Sets the clock divisor value for CAM_XCLK generation. based on CAM_MCK (value of CAM_MCLK is 96MHz) &amp;quot;&amp;quot;&amp;quot;00000&amp;quot;&amp;quot; CAM_XCLK Stable Low Level&amp;quot; Divider not enabled &amp;quot;&amp;quot;&amp;quot;00001&amp;quot;&amp;quot; CAM_XCLK Stable High Level&amp;quot; Divider not enabled from 2 to 30 CAM_XCLK = CAM_MCLK / XCLK_DIV &amp;quot;&amp;quot;&amp;quot;11111&amp;quot;&amp;quot; Bypass - CAM_XCLK = CAM_MCLK&amp;quot;</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_FIFO_DATA</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>This register allows to write to the FIFO and read from the FIFO (CCP &amp; Parallel Mode)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_TEST</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>This register shows the status of some important variables of the camera core module (CCP &amp; Parallel Mode)</description>
          <fields>
            <field>
              <name>FIFO_RD_POINTER</name>
              <description>[31:24] FIFO READ Pointer This field shows the value of the FIFO read pointer Expected value ranges from 0 to 127</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>FIFO_WR_POINTER</name>
              <description>[23:16] FIFO WRITE pointer This field shows the value of the FIFO write pointer Expected value ranges from 0 to 127</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>FIFO_LEVEL</name>
              <description>[15:8] FIFO level (how many 32-bit words the FIFO contains) This field shows the value of the FIFO level and can assume values from 0 to 128</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FIFO_LEVEL_PEAK</name>
              <description>[7:0] FIFO level peak This field shows the max value of the FIFO level and can assume values from 0 to 128</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC_GEN_PAR</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>This register shows the values of the generic parameters of the module ****************************************************************************</description>
          <fields>
            <field>
              <name>CC_FIFO_DEPTH</name>
              <description>[2:0] Camera Core FIFO DEPTH generic parameter</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S</name>
      <baseAddress>0x4401C000</baseAddress>
      <registers>
        <register>
          <name>PID</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>PID</description>
          <fields>
            <field>
              <name>SCHEME</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>FUNCTION</name>
              <description>[27:16] McASP</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RTL</name>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>REVMAJOR</name>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUSTOM</name>
              <description>[7:6] non-custom</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>REVMINOR</name>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ESYSCONFIG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Power Idle SYSCONFIG register.</description>
          <fields>
            <field>
              <name>RSV</name>
              <description>[31:6] Reserved as per PDR 3.5</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>OTHER</name>
              <description>[5:2] Reserved for future expansion</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>IDLE_MODE</name>
              <description>[1:0] Idle Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PFUNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>PFUNC</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDIR</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>PDIR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDOUT</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>PDOUT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDIN_PDSET</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>The pin data input register (PDIN) holds the I/O pin state of each of the McASP pins. PDIN allows the actual value of the pin to be read regardless of the state of PFUNC and PDIR. The pin data set register (PDSET) is an alias of the pin data output register (PDOUT) for writes only. Writing a 1 to the PDSET bit sets the corresponding bit in PDOUT and if PFUNC = 1 (GPIO function) and PDIR = 1 (output) drives a logic high on the pin.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PDCLR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>The pin data clear register (PDCLR) is an alias of the pin data output register (PDOUT) for writes only. Writing a 1 to the PDCLR bit clears the corresponding bit in PDOUT and if PFUNC = 1 (GPIO function) and PDIR = 1 (output) drives a logic low on the pin.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TLGC</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>for IODFT</description>
          <fields>
            <field>
              <name>MT</name>
              <description>[15:14] MISR on/off trigger command 0x0 0x1 0x2 0x3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>MC</name>
              <description>[5:4] States of MISR 0x0 0x1 0x2 0x3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC</name>
              <description>[3:1] Pattern code 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TLMR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>for IODFT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TLEC</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>for IODFT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GBLCTL</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GBLCTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AMUTE</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>AMUTE</description>
          <fields>
            <field>
              <name>MUTEN</name>
              <description>[1:0] AMUTE pin enable 0x0 0x1 0x2</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LBCTL</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>LBCTL</description>
          <fields>
            <field>
              <name>MODE</name>
              <description>[3:2] Loop back clock source generator 0x0 0x1 0x2 0x3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXDITCTL</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>TXDITCTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GBLCTLR</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GBLCTLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXMASK</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>RXMASK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXFMT</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>RXFMT</description>
          <fields>
            <field>
              <name>RDATDLY</name>
              <description>[17:16] RCV Frame sync delay 0x0 0 Bit delay 0x1 1 Bit delay 0x2 2 Bit delay</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RPAD</name>
              <description>[14:13] Pad value 0x0 0x1 0x2</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RPBIT</name>
              <description>[12:8] Pad bit position</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RSSZ</name>
              <description>[7:4] RCV slot Size 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xA 0xB 0xC 0xD 0xE 0xF</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RROT</name>
              <description>[2:0] Right Rotate Value 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXFMCTL</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>RXFMCTL</description>
          <fields>
            <field>
              <name>RMOD</name>
              <description>[15:7] RCV Frame sync mode</description>
              <bitWidth>9</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACLKRCTL</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>ACLKRCTL</description>
          <fields>
            <field>
              <name>CLKRADJ</name>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CLKRDIV</name>
              <description>[4:0] RCV clock devide ratio</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AHCLKRCTL</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>AHCLKRCTL</description>
          <fields>
            <field>
              <name>HCLKRADJ</name>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>HCLKRDIV</name>
              <description>[11:0] RCV clock Divide Ratio</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXTDM</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>RXTDM</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EVTCTLR</name>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <description>EVTCTLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXSTAT</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>RXSTAT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXTDMSLOT</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>RXTDMSLOT</description>
          <fields>
            <field>
              <name>RSLOTCNT</name>
              <description>[9:0] Current RCV time slot count</description>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXCLKCHK</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>RXCLKCHK</description>
          <fields>
            <field>
              <name>RCNT</name>
              <description>[31:24] RCV clock count value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RMAX</name>
              <description>[23:16] RCV clock maximum boundary</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RMIN</name>
              <description>[15:8] RCV clock minimum boundary</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RPS</name>
              <description>[3:0] RCV clock check prescaler 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REVTCTL</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>REVTCTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GBLCTLX</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>GBLCTLX</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXMASK</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>TXMASK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXFMT</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>TXFMT</description>
          <fields>
            <field>
              <name>XDATDLY</name>
              <description>[17:16] XMT Frame sync delay 0x0 0 Bit delay 0x1 1 Bit delay 0x2 2 Bit delay</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>XPAD</name>
              <description>[14:13] Pad value 0x0 0x1 0x2</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>XPBIT</name>
              <description>[12:8] Pad bit position</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>XSSZ</name>
              <description>[7:4] XMT slot Size 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xA 0xB 0xC 0xD 0xE 0xF</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>XROT</name>
              <description>[2:0] Right Rotate Value 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXFMCTL</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>TXFMCTL</description>
          <fields>
            <field>
              <name>XMOD</name>
              <description>[15:7] XMT Frame sync mode</description>
              <bitWidth>9</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACLKXCTL</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>ACLKXCTL</description>
          <fields>
            <field>
              <name>CLKXADJ</name>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CLKXDIV</name>
              <description>[4:0] XMT clock devide ratio</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AHCLKXCTL</name>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <description>AHCLKXCTL</description>
          <fields>
            <field>
              <name>HCLKXADJ</name>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>HCLKXDIV</name>
              <description>[11:0] XMT clock Divide Ratio</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXTDM</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>TXTDM</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EVTCTLX</name>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <description>EVTCTLX</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXSTAT</name>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <description>TXSTAT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXTDMSLOT</name>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <description>TXTDMSLOT</description>
          <fields>
            <field>
              <name>XSLOTCNT</name>
              <description>[9:0] Current XMT time slot count during reset the value of this register is 0b0101111111 (0x17f) and after reset 0</description>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXCLKCHK</name>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <description>TXCLKCHK</description>
          <fields>
            <field>
              <name>XCNT</name>
              <description>[31:24] XMT clock count value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>XMAX</name>
              <description>[23:16] XMT clock maximum boundary</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>XMIN</name>
              <description>[15:8] XMT clock minimum boundary</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>XPS</name>
              <description>[3:0] XMT clock check prescaler 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XEVTCTL</name>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <description>XEVTCTL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CLKADJEN</name>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <description>CLKADJEN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRA0</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>DITCSRA0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRA1</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>DITCSRA1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRA2</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>DITCSRA2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRA3</name>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <description>DITCSRA3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRA4</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>DITCSRA4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRA5</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>DITCSRA5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRB0</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>DITCSRB0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRB1</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>DITCSRB1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRB2</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>DITCSRB2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRB3</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>DITCSRB3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRB4</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>DITCSRB4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITCSRB5</name>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <description>DITCSRB5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRA0</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>DITUDRA0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRA1</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>DITUDRA1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRA2</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>DITUDRA2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRA3</name>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <description>DITUDRA3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRA4</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>DITUDRA4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRA5</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>DITUDRA5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRB0</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>DITUDRB0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRB1</name>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <description>DITUDRB1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRB2</name>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <description>DITUDRB2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRB3</name>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <description>DITUDRB3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRB4</name>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <description>DITUDRB4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DITUDRB5</name>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <description>DITUDRB5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL0</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>XRSRCTL0</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL1</name>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <description>XRSRCTL1</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL2</name>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <description>XRSRCTL2</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL3</name>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <description>XRSRCTL3</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL4</name>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <description>XRSRCTL4</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL5</name>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <description>XRSRCTL5</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL6</name>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <description>XRSRCTL6</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL7</name>
          <addressOffset>0x19C</addressOffset>
          <size>32</size>
          <description>XRSRCTL7</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL8</name>
          <addressOffset>0x1A0</addressOffset>
          <size>32</size>
          <description>XRSRCTL8</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL9</name>
          <addressOffset>0x1A4</addressOffset>
          <size>32</size>
          <description>XRSRCTL9</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL10</name>
          <addressOffset>0x1A8</addressOffset>
          <size>32</size>
          <description>XRSRCTL10</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL11</name>
          <addressOffset>0x1AC</addressOffset>
          <size>32</size>
          <description>XRSRCTL11</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL12</name>
          <addressOffset>0x1B0</addressOffset>
          <size>32</size>
          <description>XRSRCTL12</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL13</name>
          <addressOffset>0x1B4</addressOffset>
          <size>32</size>
          <description>XRSRCTL13</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL14</name>
          <addressOffset>0x1B8</addressOffset>
          <size>32</size>
          <description>XRSRCTL14</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XRSRCTL15</name>
          <addressOffset>0x1BC</addressOffset>
          <size>32</size>
          <description>XRSRCTL15</description>
          <fields>
            <field>
              <name>DISMOD</name>
              <description>[3:2] Serializer drive state 0x0 Tri state 0x1 Reserved 0x2 Drive pin low 0x3 Drive pin high</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SRMOD</name>
              <description>[1:0] Serializer Mode 0x0 InActive mode 0x1 Transmit mode 0x2 Receive mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF0</name>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <description>TXBUF0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF1</name>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <description>TXBUF1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF2</name>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <description>TXBUF2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF3</name>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <description>TXBUF3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF4</name>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <description>TXBUF4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF5</name>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <description>TXBUF5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF6</name>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <description>TXBUF6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF7</name>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <description>TXBUF7</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF8</name>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <description>TXBUF8</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF9</name>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <description>TXBUF9</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF10</name>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <description>TXBUF10</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF11</name>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <description>TXBUF11</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF12</name>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <description>TXBUF12</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF13</name>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <description>TXBUF13</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF14</name>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <description>TXBUF14</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXBUF15</name>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <description>TXBUF15</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF0</name>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <description>RXBUF0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF1</name>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <description>RXBUF1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF2</name>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <description>RXBUF2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF3</name>
          <addressOffset>0x28C</addressOffset>
          <size>32</size>
          <description>RXBUF3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF4</name>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <description>RXBUF4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF5</name>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <description>RXBUF5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF6</name>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <description>RXBUF6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF7</name>
          <addressOffset>0x29C</addressOffset>
          <size>32</size>
          <description>RXBUF7</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF8</name>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <description>RXBUF8</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF9</name>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <description>RXBUF9</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF10</name>
          <addressOffset>0x2A8</addressOffset>
          <size>32</size>
          <description>RXBUF10</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF11</name>
          <addressOffset>0x2AC</addressOffset>
          <size>32</size>
          <description>RXBUF11</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF12</name>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <description>RXBUF12</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF13</name>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <description>RXBUF13</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF14</name>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <description>RXBUF14</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXBUF15</name>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <description>RXBUF15</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SSPI</name>
      <baseAddress>0x44020000</baseAddress>
      <registers>
        <register>
          <name>HL_REV</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>IP Revision Identifier (X.Y.R) Used by software to track features bugs and compatibility</description>
          <fields>
            <field>
              <name>SCHEME</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RSVD</name>
              <description>[29:28] Reserved These bits are initialized to zero and writes to them are ignored.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>FUNC</name>
              <description>[27:16] Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>R_RTL</name>
              <description>[15:11] RTL Version (R) maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>X_MAJOR</name>
              <description>[10:8] Major Revision (X) maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUSTOM</name>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Y_MINOR</name>
              <description>[5:0] Minor Revision (Y) maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R S X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HL_HWINFO</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Information about the IP module's hardware configuration i.e. typically the module's HDL generics (if any). Actual field format and encoding is up to the module's designer to decide.</description>
          <fields>
            <field>
              <name>FFNBYTE</name>
              <bitWidth>5</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HL_SYSCONFIG</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>0x4402 1010 0x4402 2010 Clock management configuration</description>
          <fields>
            <field>
              <name>IDLEMODE</name>
              <description>[3:2] Configuration of the local target state management mode. By definition target can handle read/write transaction as long as it is out of IDLE state. 0x0 Force-idle mode: local target's idle state follows (acknowledges) the system's idle requests unconditionally i.e. regardless of the IP module's internal requirements.Backup mode for debug only. 0x1 No-idle mode: local target never enters idle state.Backup mode for debug only. 0x2 Smart-idle mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module shall not generate (IRQ- or DMA-request-related) wakeup events. 0x3 &amp;quot;Smart-idle wakeup-capable mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module may generate (IRQ- or DMA-request-related) wakeup events when in idle state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;swakeup&amp;quot;&amp;quot; output(s) is (are) implemented.&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REVISION</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>0x4402 1100 0x4402 2100 This register contains the hard coded RTL revision number.</description>
          <fields>
            <field>
              <name>REV</name>
              <description>[7:0] IP revision [7:4] Major revision [3:0] Minor revision Examples: 0x10 for 1.0 0x21 for 2.1</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCONFIG</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>0x4402 1110 0x4402 2110 This register allows controlling various parameters of the OCP interface.</description>
          <fields>
            <field>
              <name>CLOCKACTIVITY</name>
              <description>[9:8] Clocks activity during wake up mode period 0x0 OCP and Functional clocks may be switched off. 0x1 OCP clock is maintained. Functional clock may be switched-off. 0x2 Functional clock is maintained. OCP clock may be switched-off. 0x3 OCP and Functional clocks are maintained.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SIDLEMODE</name>
              <description>[4:3] Power management 0x0 If an idle request is detected the McSPI acknowledges it unconditionally and goes in Inactive mode. Interrupt DMA requests and wake up lines are unconditionally de-asserted and the module wakeup capability is deactivated even if the bit MCSPI_SYSCONFIG[EnaWakeUp] is set. 0x1 If an idle request is detected the request is ignored and the module does not switch to wake up mode and keeps on behaving normally. 0x2 If an idle request is detected the module will switch to idle mode based on its internal activity. The wake up capability cannot be used. 0x3 If an idle request is detected the module will switch to idle mode based on its internal activity and the wake up capability can be used if the bit MCSPI_SYSCONFIG[EnaWakeUp] is set.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSSTATUS</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>0x4402 1114 0x4402 2114 This register provides status information about the module excluding the interrupt status information</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQSTATUS</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>0x4402 1118 0x4402 2118 The interrupt status regroups all the status of the module internal events that can generate an interrupt</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQENABLE</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>0x4402 111C 0x4402 211C This register allows to enable/disable the module internal sources of interrupt on an event-by-event basis.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WAKEUPENABLE</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>0x4402 1120 0x4402 2120 The wakeup enable register allows to enable/disable the module internal sources of wakeup on event-by-event basis.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYST</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>0x4402 1124 0x4402 2124 This register is used to check the correctness of the system interconnect either internally to peripheral bus or externally to device IO pads when the module is configured in system test (SYSTEST) mode.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MODULCTRL</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>0x4402 1128 0x4402 2128 This register is dedicated to the configuration of the serial port interface.</description>
          <fields>
            <field>
              <name>INITDLY</name>
              <description>[6:4] Initial spi delay for first transfer: This register is an option only available in SINGLE master mode The controller waits for a delay to transmit the first spi word after channel enabled and corresponding TX register filled. This Delay is based on SPI output frequency clock No clock output provided to the boundary and chip select is not active in 4 pin mode within this period. 0x0 No delay for first spi transfer. 0x1 The controller wait 4 spi bus clock 0x2 The controller wait 8 spi bus clock 0x3 The controller wait 16 spi bus clock 0x4 The controller wait 32 spi bus clock</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0CONF</name>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <description>0x4402 112C 0x4402 212C This register is dedicated to the configuration of the channel 0</description>
          <fields>
            <field>
              <name>TCS0</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>SPIENSLV</name>
              <description>[22:21] Channel 0 only and slave mode only: SPI slave select signal detection. Reserved bits for other cases. 0x0 Detection enabled only on SPIEN[0] 0x1 Detection enabled only on SPIEN[1] 0x2 Detection enabled only on SPIEN[2] 0x3 Detection enabled only on SPIEN[3]</description>
              <bitWidth>2</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0STAT</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>0x4402 1130 0x4402 2130 This register provides status information about transmitter and receiver registers of channel 0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0CTRL</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>0x4402 1134 0x4402 2134 This register is dedicated to enable the channel 0</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX0</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>0x4402 1138 0x4402 2138 This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX0</name>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <description>0x4402 113C 0x4402 213C This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1CONF</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>0x4402 1140 0x4402 2140 This register is dedicated to the configuration of the channel.</description>
          <fields>
            <field>
              <name>TCS1</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1STAT</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>0x4402 1144 0x4402 2144 This register provides status information about transmitter and receiver registers of channel 1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1CTRL</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>0x4402 1148 0x4402 2148 This register is dedicated to enable the channel 1</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX1</name>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <description>0x4402 114C 0x4402 214C This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX1</name>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <description>0x4402 1150 0x4402 2150 This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2CONF</name>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <description>0x4402 1154 0x4402 2154 This register is dedicated to the configuration of the channel 2</description>
          <fields>
            <field>
              <name>TCS2</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2STAT</name>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <description>0x4402 1158 0x4402 2158 This register provides status information about transmitter and receiver registers of channel 2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2CTRL</name>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <description>0x4402 115C 0x4402 215C This register is dedicated to enable the channel 2</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX2</name>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <description>0x4402 1160 0x4402 2160 This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX2</name>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <description>0x4402 1164 0x4402 2164 This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3CONF</name>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <description>0x4402 1168 0x4402 2168 This register is dedicated to the configuration of the channel 3</description>
          <fields>
            <field>
              <name>TCS3</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3STAT</name>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <description>0x4402 116C 0x4402 216C This register provides status information about transmitter and receiver registers of channel 3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3CTRL</name>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <description>0x4402 1170 0x4402 2170 This register is dedicated to enable the channel 3</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX3</name>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <description>0x4402 1174 0x4402 2174 This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX3</name>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <description>0x4402 1178 0x4402 2178 This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XFERLEVEL</name>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <description>0x4402 117C 0x4402 217C This register provides transfer levels needed while using FIFO buffer during transfer.</description>
          <fields>
            <field>
              <name>WCNT</name>
              <description>[31:16] Spi word counterThis register holds the programmable value of number of SPI word to be transferred on channel which is using the FIFO buffer.When transfer had started a read back in this register returns the current SPI word transfer index. 0x0000 Counter not used 0x0001 one word 0xFFFE 65534 spi word 0xFFFF 65535 spi word</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>AFL</name>
              <description>[15:8] Buffer Almost Full This register holds the programmable almost full level value used to determine almost full buffer condition. If the user wants an interrupt or a DMA read request to be issued during a receive operation when the data buffer holds at least n bytes then the buffer MCSPI_MODULCTRL[AFL] must be set with n-1.The size of this register is defined by the generic parameter FFNBYTE. 0x00 one byte 0x01 2 bytes 0xFE 255bytes 0xFF 256bytes</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AEL</name>
              <description>[7:0] Buffer Almost EmptyThis register holds the programmable almost empty level value used to determine almost empty buffer condition. If the user wants an interrupt or a DMA write request to be issued during a transmit operation when the data buffer is able to receive n bytes then the buffer MCSPI_MODULCTRL[AEL] must be set with n-1. 0x00 one byte 0x01 2 bytes 0xFE 255 bytes 0xFF 256bytes</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DAFTX</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>0x4402 1180 0x4402 2180 This register contains the SPI words to transmit on the serial link when FIFO used and DMA address is aligned on 256 bit.This register is an image of one of MCSPI_TX(i) register corresponding to the channel which have its FIFO enabled.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DAFRX</name>
          <addressOffset>0x1A0</addressOffset>
          <size>32</size>
          <description>0x4402 11A0 0x4402 21A0 This register contains the SPI words to received on the serial link when FIFO used and DMA address is aligned on 256 bit.This register is an image of one of MCSPI_RX(i) register corresponding to the channel which have its FIFO enabled. ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GSPI</name>
      <baseAddress>0x44021000</baseAddress>
      <registers>
        <register>
          <name>HL_REV</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>IP Revision Identifier (X.Y.R) Used by software to track features bugs and compatibility</description>
          <fields>
            <field>
              <name>SCHEME</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RSVD</name>
              <description>[29:28] Reserved These bits are initialized to zero and writes to them are ignored.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>FUNC</name>
              <description>[27:16] Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>R_RTL</name>
              <description>[15:11] RTL Version (R) maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>X_MAJOR</name>
              <description>[10:8] Major Revision (X) maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUSTOM</name>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Y_MINOR</name>
              <description>[5:0] Minor Revision (Y) maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R S X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HL_HWINFO</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Information about the IP module's hardware configuration i.e. typically the module's HDL generics (if any). Actual field format and encoding is up to the module's designer to decide.</description>
          <fields>
            <field>
              <name>FFNBYTE</name>
              <bitWidth>5</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HL_SYSCONFIG</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>0x4402 1010 0x4402 2010 Clock management configuration</description>
          <fields>
            <field>
              <name>IDLEMODE</name>
              <description>[3:2] Configuration of the local target state management mode. By definition target can handle read/write transaction as long as it is out of IDLE state. 0x0 Force-idle mode: local target's idle state follows (acknowledges) the system's idle requests unconditionally i.e. regardless of the IP module's internal requirements.Backup mode for debug only. 0x1 No-idle mode: local target never enters idle state.Backup mode for debug only. 0x2 Smart-idle mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module shall not generate (IRQ- or DMA-request-related) wakeup events. 0x3 &amp;quot;Smart-idle wakeup-capable mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module may generate (IRQ- or DMA-request-related) wakeup events when in idle state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;swakeup&amp;quot;&amp;quot; output(s) is (are) implemented.&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REVISION</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>0x4402 1100 0x4402 2100 This register contains the hard coded RTL revision number.</description>
          <fields>
            <field>
              <name>REV</name>
              <description>[7:0] IP revision [7:4] Major revision [3:0] Minor revision Examples: 0x10 for 1.0 0x21 for 2.1</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCONFIG</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>0x4402 1110 0x4402 2110 This register allows controlling various parameters of the OCP interface.</description>
          <fields>
            <field>
              <name>CLOCKACTIVITY</name>
              <description>[9:8] Clocks activity during wake up mode period 0x0 OCP and Functional clocks may be switched off. 0x1 OCP clock is maintained. Functional clock may be switched-off. 0x2 Functional clock is maintained. OCP clock may be switched-off. 0x3 OCP and Functional clocks are maintained.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SIDLEMODE</name>
              <description>[4:3] Power management 0x0 If an idle request is detected the McSPI acknowledges it unconditionally and goes in Inactive mode. Interrupt DMA requests and wake up lines are unconditionally de-asserted and the module wakeup capability is deactivated even if the bit MCSPI_SYSCONFIG[EnaWakeUp] is set. 0x1 If an idle request is detected the request is ignored and the module does not switch to wake up mode and keeps on behaving normally. 0x2 If an idle request is detected the module will switch to idle mode based on its internal activity. The wake up capability cannot be used. 0x3 If an idle request is detected the module will switch to idle mode based on its internal activity and the wake up capability can be used if the bit MCSPI_SYSCONFIG[EnaWakeUp] is set.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSSTATUS</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>0x4402 1114 0x4402 2114 This register provides status information about the module excluding the interrupt status information</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQSTATUS</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>0x4402 1118 0x4402 2118 The interrupt status regroups all the status of the module internal events that can generate an interrupt</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQENABLE</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>0x4402 111C 0x4402 211C This register allows to enable/disable the module internal sources of interrupt on an event-by-event basis.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WAKEUPENABLE</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>0x4402 1120 0x4402 2120 The wakeup enable register allows to enable/disable the module internal sources of wakeup on event-by-event basis.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYST</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>0x4402 1124 0x4402 2124 This register is used to check the correctness of the system interconnect either internally to peripheral bus or externally to device IO pads when the module is configured in system test (SYSTEST) mode.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MODULCTRL</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>0x4402 1128 0x4402 2128 This register is dedicated to the configuration of the serial port interface.</description>
          <fields>
            <field>
              <name>INITDLY</name>
              <description>[6:4] Initial spi delay for first transfer: This register is an option only available in SINGLE master mode The controller waits for a delay to transmit the first spi word after channel enabled and corresponding TX register filled. This Delay is based on SPI output frequency clock No clock output provided to the boundary and chip select is not active in 4 pin mode within this period. 0x0 No delay for first spi transfer. 0x1 The controller wait 4 spi bus clock 0x2 The controller wait 8 spi bus clock 0x3 The controller wait 16 spi bus clock 0x4 The controller wait 32 spi bus clock</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0CONF</name>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <description>0x4402 112C 0x4402 212C This register is dedicated to the configuration of the channel 0</description>
          <fields>
            <field>
              <name>TCS0</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>SPIENSLV</name>
              <description>[22:21] Channel 0 only and slave mode only: SPI slave select signal detection. Reserved bits for other cases. 0x0 Detection enabled only on SPIEN[0] 0x1 Detection enabled only on SPIEN[1] 0x2 Detection enabled only on SPIEN[2] 0x3 Detection enabled only on SPIEN[3]</description>
              <bitWidth>2</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0STAT</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>0x4402 1130 0x4402 2130 This register provides status information about transmitter and receiver registers of channel 0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0CTRL</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>0x4402 1134 0x4402 2134 This register is dedicated to enable the channel 0</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX0</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>0x4402 1138 0x4402 2138 This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX0</name>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <description>0x4402 113C 0x4402 213C This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1CONF</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>0x4402 1140 0x4402 2140 This register is dedicated to the configuration of the channel.</description>
          <fields>
            <field>
              <name>TCS1</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1STAT</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>0x4402 1144 0x4402 2144 This register provides status information about transmitter and receiver registers of channel 1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1CTRL</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>0x4402 1148 0x4402 2148 This register is dedicated to enable the channel 1</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX1</name>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <description>0x4402 114C 0x4402 214C This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX1</name>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <description>0x4402 1150 0x4402 2150 This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2CONF</name>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <description>0x4402 1154 0x4402 2154 This register is dedicated to the configuration of the channel 2</description>
          <fields>
            <field>
              <name>TCS2</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2STAT</name>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <description>0x4402 1158 0x4402 2158 This register provides status information about transmitter and receiver registers of channel 2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2CTRL</name>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <description>0x4402 115C 0x4402 215C This register is dedicated to enable the channel 2</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX2</name>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <description>0x4402 1160 0x4402 2160 This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX2</name>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <description>0x4402 1164 0x4402 2164 This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3CONF</name>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <description>0x4402 1168 0x4402 2168 This register is dedicated to the configuration of the channel 3</description>
          <fields>
            <field>
              <name>TCS3</name>
              <description>[26:25] Chip Select Time Control This 2-bits field defines the number of interface clock cycles between CS toggling and first or last edge of SPI clock. 0x0 0.5 clock cycle 0x1 1.5 clock cycle 0x2 2.5 clock cycle 0x3 3.5 clock cycle</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>TRM</name>
              <description>[13:12] Transmit/Receive modes 0x0 Transmit and Receive mode 0x1 Receive only mode 0x2 Transmit only mode 0x3 Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WL</name>
              <description>[11:7] SPI word length 0x00 Reserved 0x01 Reserved 0x02 Reserved 0x03 The SPI word is 4-bits long 0x04 The SPI word is 5-bits long 0x05 The SPI word is 6-bits long 0x06 The SPI word is 7-bits long 0x07 The SPI word is 8-bits long 0x08 The SPI word is 9-bits long 0x09 The SPI word is 10-bits long 0x0A The SPI word is 11-bits long 0x0B The SPI word is 12-bits long 0x0C The SPI word is 13-bits long 0x0D The SPI word is 14-bits long 0x0E The SPI word is 15-bits long 0x0F The SPI word is 16-bits long 0x10 The SPI word is 17-bits long 0x11 The SPI word is 18-bits long 0x12 The SPI word is 19-bits long 0x13 The SPI word is 20-bits long 0x14 The SPI word is 21-bits long 0x15 The SPI word is 22-bits long 0x16 The SPI word is 23-bits long 0x17 The SPI word is 24-bits long 0x18 The SPI word is 25-bits long 0x19 The SPI word is 26-bits long 0x1A The SPI word is 27-bits long 0x1B The SPI word is 28-bits long 0x1C The SPI word is 29-bits long 0x1D The SPI word is 30-bits long 0x1E The SPI word is 31-bits long 0x1F The SPI word is 32-bits long</description>
              <bitWidth>5</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLKD</name>
              <description>[5:2] Frequency divider for SPICLK. (only when the module is a Master SPI device). A programmable clock divider divides the SPI reference clock (CLKSPIREF) with a 4-bit value and results in a new clock SPICLK available to shift-in and shift-out data. By default the clock divider ratio has a power of two granularity when MCSPI_CHCONF[CLKG] is cleared Otherwise this register is the 4 LSB bit of a 12-bit register concatenated with clock divider extension MCSPI_CHCTRL[EXTCLK] register.The value description below defines the clock ratio when MCSPI_CHCONF[CLKG] is set to 0. 0x0 1 0x1 2 0x2 4 0x3 8 0x4 16 0x5 32 0x6 64 0x7 128 0x8 256 0x9 512 0xA 1024 0xB 2048 0xC 4096 0xD 8192 0xE 16384 0xF 32768</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3STAT</name>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <description>0x4402 116C 0x4402 216C This register provides status information about transmitter and receiver registers of channel 3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3CTRL</name>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <description>0x4402 1170 0x4402 2170 This register is dedicated to enable the channel 3</description>
          <fields>
            <field>
              <name>EXTCLK</name>
              <description>[15:8] Clock ratio extension: This register is used to concatenate with MCSPI_CHCONF[CLKD] register for clock ratio only when granularity is one clock cycle (MCSPI_CHCONF[CLKG] set to 1). Then the max value reached is 4096 clock divider ratio. 0x00 Clock ratio is CLKD + 1 0x01 Clock ratio is CLKD + 1 + 16 0xFF Clock ratio is CLKD + 1 + 4080</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TX3</name>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <description>0x4402 1174 0x4402 2174 This register contains a single SPI word to transmit on the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RX3</name>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <description>0x4402 1178 0x4402 2178 This register contains a single SPI word received through the serial link what ever SPI word length is.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>XFERLEVEL</name>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <description>0x4402 117C 0x4402 217C This register provides transfer levels needed while using FIFO buffer during transfer.</description>
          <fields>
            <field>
              <name>WCNT</name>
              <description>[31:16] Spi word counterThis register holds the programmable value of number of SPI word to be transferred on channel which is using the FIFO buffer.When transfer had started a read back in this register returns the current SPI word transfer index. 0x0000 Counter not used 0x0001 one word 0xFFFE 65534 spi word 0xFFFF 65535 spi word</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>AFL</name>
              <description>[15:8] Buffer Almost Full This register holds the programmable almost full level value used to determine almost full buffer condition. If the user wants an interrupt or a DMA read request to be issued during a receive operation when the data buffer holds at least n bytes then the buffer MCSPI_MODULCTRL[AFL] must be set with n-1.The size of this register is defined by the generic parameter FFNBYTE. 0x00 one byte 0x01 2 bytes 0xFE 255bytes 0xFF 256bytes</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AEL</name>
              <description>[7:0] Buffer Almost EmptyThis register holds the programmable almost empty level value used to determine almost empty buffer condition. If the user wants an interrupt or a DMA write request to be issued during a transmit operation when the data buffer is able to receive n bytes then the buffer MCSPI_MODULCTRL[AEL] must be set with n-1. 0x00 one byte 0x01 2 bytes 0xFE 255 bytes 0xFF 256bytes</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DAFTX</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>0x4402 1180 0x4402 2180 This register contains the SPI words to transmit on the serial link when FIFO used and DMA address is aligned on 256 bit.This register is an image of one of MCSPI_TX(i) register corresponding to the channel which have its FIFO enabled.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DAFRX</name>
          <addressOffset>0x1A0</addressOffset>
          <size>32</size>
          <description>0x4402 11A0 0x4402 21A0 This register contains the SPI words to received on the serial link when FIFO used and DMA address is aligned on 256 bit.This register is an image of one of MCSPI_RX(i) register corresponding to the channel which have its FIFO enabled. ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ARCM</name>
      <baseAddress>0x44025000</baseAddress>
      <registers>
        <register>
          <name>CAMERA_CLK_GEN</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>CAMERA_CLK_GEN</description>
          <fields>
            <field>
              <name>CAMERA_PLLCKDIV_OFF_TIME</name>
              <description>[10:8] Configuration of OFF-TIME for dividing PLL clk (240 MHz) in generation of Camera func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NU1</name>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAMERA_PLLCKDIV_ON_TIME</name>
              <description>[2:0] Configuration of ON-TIME for dividing PLL clk (240 MHz) in generation of Camera func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CAMERA_CLK_GATING</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>CAMERA_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU3</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CAMERA_SOFT_RESET</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>CAMERA_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCASP_CLK_GATING</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>MCASP_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU3</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCASP_SOFT_RESET</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>MCASP_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MMCHS_CLK_GEN</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>MMCHS_CLK_GEN</description>
          <fields>
            <field>
              <name>MMCHS_PLLCKDIV_OFF_TIME</name>
              <description>[10:8] Configuration of OFF-TIME for dividing PLL clk (240 MHz) in generation of MMCHS func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NU1</name>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MMCHS_PLLCKDIV_ON_TIME</name>
              <description>[2:0] Configuration of ON-TIME for dividing PLL clk (240 MHz) in generation of MMCHS func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MMCHS_CLK_GATING</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>MMCHS_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU3</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MMCHS_SOFT_RESET</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>MMCHS_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_A1_CLK_GEN</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>MCSPI_A1_CLK_GEN</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MCSPI_A1_PLLCLKDIV_OFF_TIME</name>
              <description>[10:8] Configuration of OFF-TIME for dividing PLL clk (240 MHz) in generation of MCSPI_A1 func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MCSPI_A1_PLLCLKDIV_ON_TIME</name>
              <description>[2:0] Configuration of ON-TIME for dividing PLL clk (240 MHz) in generation of MCSPI_A1 func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_A1_CLK_GATING</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>MCSPI_A1_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU3</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_A1_SOFT_RESET</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>MCSPI_A1_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_A2_CLK_GEN</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>MCSPI_A2_CLK_GEN</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MCSPI_A2_PLLCKDIV_OFF_TIME</name>
              <description>[10:8] Configuration of OFF-TIME for dividing PLL clk (240 MHz) in generation of MCSPI_A2 func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MCSPI_A2_PLLCKDIV_ON_TIME</name>
              <description>[2:0] Configuration of OFF-TIME for dividing PLL clk (240 MHz) in generation of MCSPI_A2 func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_A2_CLK_GATING</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>MCSPI_A2_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU3</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_A2_SOFT_RESET</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>MCSPI_A2_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UDMA_A_CLK_GATING</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>UDMA_A_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UDMA_A_SOFT_RESET</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>UDMA_A_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_A_CLK_GATING</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPIO_A_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_A_SOFT_RESET</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPIO_A_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_B_CLK_GATING</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>GPIO_B_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_B_SOFT_RESET</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>GPIO_B_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_C_CLK_GATING</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPIO_C_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_C_SOFT_RESET</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPIO_C_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_D_CLK_GATING</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPIO_D_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_D_SOFT_RESET</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>GPIO_D_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_E_CLK_GATING</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>GPIO_E_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_E_SOFT_RESET</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>GPIO_E_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WDOG_A_CLK_GATING</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>WDOG_A_CLK_GATING</description>
          <fields>
            <field>
              <name>WDOG_A_BAUD_CLK_SEL</name>
              <description>[25:24] &amp;quot;00&amp;quot; - Sysclk ; &amp;quot;01&amp;quot; - REF_CLK (38.4 MHz) ; &amp;quot;10/11&amp;quot; - Slow_clk</description>
              <bitWidth>2</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WDOG_A_SOFT_RESET</name>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <description>WDOG_A_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_A0_CLK_GATING</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>UART_A0_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_A0_SOFT_RESET</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>UART_A0_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_A1_CLK_GATING</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>UART_A1_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UART_A1_SOFT_RESET</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>UART_A1_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A0_CLK_GATING</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>GPT_A0_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A0_SOFT_RESET</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>GPT_A0_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A1_CLK_GATING</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>GPT_A1_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A1_SOFT_RESET</name>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <description>GPT_A1_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A2_CLK_GATING</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>GPT_A2_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A2_SOFT_RESET</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>GPT_A2_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A3_CLK_GATING</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>GPT_A3_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_A3_SOFT_RESET</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>GPT_A3_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCASP_FRAC_CLK_CONFIG0</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>MCASP_FRAC_CLK_CONFIG0</description>
          <fields>
            <field>
              <name>MCASP_FRAC_DIV_DIVISOR</name>
              <bitWidth>10</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MCASP_FRAC_DIV_FRACTION</name>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCASP_FRAC_CLK_CONFIG1</name>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <description>MCASP_FRAC_CLK_CONFIG1</description>
          <fields>
            <field>
              <name>MCASP_FRAC_DIV_PERIOD</name>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CRYPTO_CLK_GATING</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>CRYPTO_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CRYPTO_SOFT_RESET</name>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <description>CRYPTO_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_S0_CLK_GATING</name>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <description>MCSPI_S0_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_S0_SOFT_RESET</name>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <description>MCSPI_S0_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_S0_CLKDIV_CFG</name>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <description>MCSPI_S0_CLKDIV_CFG</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MCSPI_S0_PLLCLKDIV_OFF_TIME</name>
              <description>[10:8] Configuration of OFF-TIME for dividing PLL clk (240 MHz) in generation of MCSPI_S0 func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MCSPI_S0_PLLCLKDIV_ON_TIME</name>
              <description>[2:0] Configuration of ON-TIME for dividing PLL clk (240 MHz) in generation of MCSPI_S0 func-clk : &amp;quot;000&amp;quot; - 1 &amp;quot;001&amp;quot; - 2 &amp;quot;010&amp;quot; - 3 &amp;quot;011&amp;quot; - 4 &amp;quot;100&amp;quot; - 5 &amp;quot;101&amp;quot; - 6 &amp;quot;110&amp;quot; - 7 &amp;quot;111&amp;quot; - 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>I2C_CLK_GATING</name>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <description>I2C_CLK_GATING</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>NU2</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>I2C_SOFT_RESET</name>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <description>I2C_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_LPDS_REQ</name>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <description>APPS_LPDS_REQ</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_TURBO_REQ</name>
          <addressOffset>0xEC</addressOffset>
          <size>32</size>
          <description>APPS_TURBO_REQ</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_DSLP_WAKE_CONFIG</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>APPS_DSLP_WAKE_CONFIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_DSLP_WAKE_TIMER_CFG</name>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <description>APPS_DSLP_WAKE_TIMER_CFG</description>
          <fields>
            <field>
              <name>DSLP_WAKE_TIMER_OPP_CFG</name>
              <description>[31:16] Configuration (in slow_clks) which says when to request for OPP during deep-sleep exit</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DSLP_WAKE_TIMER_WAKE_CFG</name>
              <description>[15:0] Configuration (in slow_clks) which says when to request for WAKE during deep-sleep exit</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SLP_WAKE_ENABLE</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>SLP_WAKE_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SLP_WAKETIMER_CFG</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>APPS_SLP_WAKETIMER_CFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_TO_NWP_WAKE_REQUEST</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>APPS_TO_NWP_WAKE_REQUEST</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>INTERRUPT_STATUS</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>INTERRUPT_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>INTERRUPT_ENABLE</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>INTERRUPT_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>APPS_CONFIG</name>
      <baseAddress>0x44026000</baseAddress>
      <registers>
        <register>
          <name>PATCH_TRAP_ADDR_REG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Patch trap address Register array</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PATCH_TRAP_EN_REG</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>PATCH_TRAP_EN_REG</description>
          <fields>
            <field>
              <name>PATCH_TRAP_EN</name>
              <description>[29:0] When PATCH_TRAP_EN[n] is set bus fault is generated for the address PATCH_TRAP_ADD[n][31:0] from Idcode bus. The exception routine should take care to jump to the location where the patch correspond to this address is kept.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FAULT_STATUS_REG</name>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <description>FAULT_STATUS_REG</description>
          <fields>
            <field>
              <name>PATCH_ERR_INDEX</name>
              <description>[5:1] This field shows because of which patch trap address the bus_fault is generated. If the PATCH_ERR bit is set, then it means the bus fault is generated because of PATCH_TRAP_ADDR_REG[2^PATCH_ERR_INDEX]</description>
              <bitWidth>5</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEMSS_WR_ERR_CLR_REG</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>MEMSS_WR_ERR_CLR_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEMSS_WR_ERR_ADDR_REG</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>MEMSS_WR_ERR_ADDR_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_DONE_INT_MASK</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>DMA_DONE_INT_MASK</description>
          <fields>
            <field>
              <name>ADC_WR_DMA_DONE_INT_MASK</name>
              <description>[15:12] 1= disable corresponding interrupt;0 = interrupt enabled bit 14: ADC channel 7 interrupt enable/disable bit 13: ADC channel 5 interrupt enable/disable bit 12: ADC channel 3 interrupt enable/disable bit 11: ADC channel 1 interrupt enable/disable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_DONE_INT_MASK_SET</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>DMA_DONE_INT_MASK_SET</description>
          <fields>
            <field>
              <name>ADC_WR_DMA_DONE_INT_MASK_SET</name>
              <description>[15:12] write 1 to set mask of the corresponding DMA DONE IRQ;0 = no effect bit 14: ADC channel 7 DMA Done IRQ bit 13: ADC channel 5 DMA Done IRQ bit 12: ADC channel 3 DMA Done IRQ bit 11: ADC channel 1 DMA Done IRQ</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_DONE_INT_MASK_CLR</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>DMA_DONE_INT_MASK_CLR</description>
          <fields>
            <field>
              <name>ADC_WR_DMA_DONE_INT_MASK_CLR</name>
              <description>[15:12] write 1 to clear mask of the corresponding DMA DONE IRQ;0 = no effect bit 14: ADC channel 7 DMA Done IRQ mask bit 13: ADC channel 5 DMA Done IRQ mask bit 12: ADC channel 3 DMA Done IRQ mask bit 11: ADC channel 1 DMA Done IRQ mask</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_DONE_INT_STS_CLR</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>DMA_DONE_INT_STS_CLR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_DONE_INT_ACK</name>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <description>DMA_DONE_INT_ACK</description>
          <fields>
            <field>
              <name>ADC_WR_DMA_DONE_INT_ACK</name>
              <description>[15:12] write 1 to clear corresponding interrupt; 0 = no effect; bit 14: ADC channel 7 DMA Done IRQ bit 13: ADC channel 5 DMA Done IRQ bit 12: ADC channel 3 DMA Done IRQ bit 11: ADC channel 1 DMA Done IRQ</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_DONE_INT_STS_MASKED</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>DMA_DONE_INT_STS_MASKED</description>
          <fields>
            <field>
              <name>ADC_WR_DMA_DONE_INT_STS_MASKED</name>
              <description>[15:12] 1= corresponding interrupt is active and not masked. read is non-destructive;0 = corresponding interrupt is inactive or masked by DMA_DONE_INT mask bit 14: ADC channel 7 DMA Done IRQ bit 13: ADC channel 5 DMA Done IRQ bit 12: ADC channel 3 DMA Done IRQ bit 11: ADC channel 1 DMA Done IRQ</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_DONE_INT_STS_RAW</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>DMA_DONE_INT_STS_RAW</description>
          <fields>
            <field>
              <name>ADC_WR_DMA_DONE_INT_STS_RAW</name>
              <description>[15:12] 1= corresponding interrupt is active. read is non-destructive;0 = corresponding interrupt is inactive bit 14: ADC channel 7 DMA Done IRQ bit 13: ADC channel 5 DMA Done IRQ bit 12: ADC channel 3 DMA Done IRQ bit 11: ADC channel 1 DMA Done IRQ</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FAULT_STATUS_CLR_REG</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>FAULT_STATUS_CLR_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RESERVD_REG_0</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>RESERVD_REG_0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT_TRIG_SEL</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>GPT_TRIG_SEL</description>
          <fields>
            <field>
              <name>GPT_TRIG_SEL</name>
              <description>[7:0] This bit is implemented for GPT trigger mode select. GPT IP support 2 modes: RTC mode and external trigger. When this bit is set to logic '1': enable external trigger mode for APPS GPT CP0 and CP1 pin. bit 0: when set '1' enable external GPT trigger 0 on GPIO0 CP0 pin else RTC mode is selected. bit 1: when set '1' enable external GPT trigger 1 on GPIO0 CP1 pin else RTC mode is selected. bit 2: when set '1' enable external GPT trigger 2 on GPIO1 CP0 pin else RTC mode is selected. bit 3: when set '1' enable external GPT trigger 3 on GPIO1 CP1 pin else RTC mode is selected. bit 4: when set '1' enable external GPT trigger 4 on GPIO2 CP0 pin else RTC mode is selected. bit 5: when set '1' enable external GPT trigger 5 on GPIO2 CP1 pin else RTC mode is selected. bit 6: when set '1' enable external GPT trigger 6 on GPIO3 CP0 pin else RTC mode is selected. bit 7: when set '1' enable external GPT trigger 7 on GPIO3 CP1 pin else RTC mode is selected.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TOP_DIE_SPARE_DIN_REG</name>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <description>TOP_DIE_SPARE_DIN_REG</description>
          <fields>
            <field>
              <name>D2D_SPARE_DIN</name>
              <description>[2:0] Capture data from d2d_spare pads</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TOP_DIE_SPARE_DOUT_REG</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>TOP_DIE_SPARE_DOUT_REG</description>
          <fields>
            <field>
              <name>D2D_SPARE_DOUT</name>
              <description>[2:0] Send data to d2d_spare pads - eventually this will get registered in top die</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPRCM</name>
      <baseAddress>0x4402D000</baseAddress>
      <registers>
        <register>
          <name>APPS_SOFT_RESET</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>APPS_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_LPDS_WAKEUP_CFG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>APPS_LPDS_WAKEUP_CFG</description>
          <fields>
            <field>
              <name>APPS_LPDS_WAKEUP_CFG</name>
              <description>[7:0] Mask for LPDS Wakeup interrupt : [7] - Host IRQ from NWP [6] - NWP_LPDS_Wake_irq (TRUE_LPDS) [5] - NWP Wake-request to APPS [4] - GPIO [3:1] - Reserved [0] - LPDS Wakeup-timer</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_LPDS_WAKEUP_SRC</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>APPS_LPDS_WAKEUP_SRC</description>
          <fields>
            <field>
              <name>APPS_LPDS_WAKEUP_SRC</name>
              <description>[7:0] Indicates the cause for wakeup from LPDS : [7] - Host IRQ from NWP [6] - NWP_LPDS_Wake_irq (TRUE_LPDS) [5] - NWP Wake-request to APPS [4] - GPIO [3:1] - Reserved [0] - LPDS Wakeup-timer</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_RESET_CAUSE</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>APPS_RESET_CAUSE</description>
          <fields>
            <field>
              <name>APPS_RESET_CAUSE</name>
              <description>[7:0] Indicates the reset cause for APPS : &amp;quot;0000&amp;quot; - Wake from HIB/OFF mode; &amp;quot;0001&amp;quot; - Wake from LPDS ; &amp;quot;0010&amp;quot; - Reserved ; &amp;quot;0011&amp;quot; - Soft-reset0 (Only APPS Cortex-sysrstn is asserted); &amp;quot;0100&amp;quot; - Soft-reset1 (APPS Cortex-sysrstn and APPS peripherals are reset); &amp;quot;0101&amp;quot; - WDOG0 (APPS Cortex-sysrstn and APPS peripherals are reset); &amp;quot;0110&amp;quot; - MCU Soft-reset (APPS + NWP Cortex-sysrstn + Peripherals are reset); &amp;quot;0111&amp;quot; - Secure Init done (Indication that reset has happened after DevInit); &amp;quot;1000&amp;quot; - Dev Mode Patch Init done (During development mode, patch downloading and Cortex re-vectoring is completed)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_LPDS_WAKETIME_OPP_CFG</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>APPS_LPDS_WAKETIME_OPP_CFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SRAM_DSLP_CFG</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>APPS_SRAM_DSLP_CFG</description>
          <fields>
            <field>
              <name>APPS_SRAM_DSLP_CFG</name>
              <description>[19:0] Configuration of APPS Memories during Deep-sleep : 0 - SRAMs are OFF ; 1 - SRAMs are Retained. APPS SRAM Cluster information : [0] - 1st column in MEMSS (Applicable only when owned by APPS); [1] - 2nd column in MEMSS (Applicable only when owned by APPS); [2] - 3rd column in MEMSS (Applicable only when owned by APPS) ; [3] - 4th column in MEMSS (Applicable only when owned by APPS) ; [16] - MCU-PD - Apps cluster 0 (TBD); [19:18] - Reserved.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SRAM_LPDS_CFG</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>APPS_SRAM_LPDS_CFG</description>
          <fields>
            <field>
              <name>APPS_SRAM_LPDS_CFG</name>
              <description>[19:0] Configuration of APPS Memories during LPDS : 0 - SRAMs are OFF ; 1 - SRAMs are Retained. APPS SRAM Cluster information : [0] - 1st column in MEMSS (Applicable only when owned by APPS); [1] - 2nd column in MEMSS (Applicable only when owned by APPS); [2] - 3rd column in MEMSS (Applicable only when owned by APPS) ; [3] - 4th column in MEMSS (Applicable only when owned by APPS) ; [16] - MCU-PD - Apps cluster 0 (TBD); [19:18] - Reserved.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_LPDS_WAKETIME_WAKE_CFG</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>APPS_LPDS_WAKETIME_WAKE_CFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TOP_DIE_ENABLE</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>TOP_DIE_ENABLE</description>
          <fields>
            <field>
              <name>TOP_DIE_PWR_PS</name>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TOP_DIE_ENABLE_PARAMETERS</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>TOP_DIE_ENABLE_PARAMETERS</description>
          <fields>
            <field>
              <name>FLASH_3P3_RSTN2D2D_POR_RSTN</name>
              <description>[31:28] Configuration (in slow_clks) for number of clks between Flash-3p3-rstn to D2D POR Resetn.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>TOP_DIE_SW_EN2TOP_DIE_FLASH_3P3_RSTN</name>
              <description>[23:16] Configuration (in slow_clks) for number of clks between Top-die Switch-Enable and Top-die Flash 3p3 Reset removal</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TOP_DIE_POR_RSTN2BOTT_DIE_FMC_RSTN</name>
              <description>[7:0] Configuration (in slow_clks) for number of clks between D2D POR Reset removal and bottom die FMC reset removal</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCU_GLOBAL_SOFT_RESET</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>MCU_GLOBAL_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADC_CLK_CONFIG</name>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <description>ADC_CLK_CONFIG</description>
          <fields>
            <field>
              <name>ADC_CLKGEN_OFF_TIME</name>
              <description>[10:6] Configuration (in number of 38.4 MHz clks) for the OFF-Time in generation of ADC_CLK</description>
              <bitWidth>5</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ADC_CLKGEN_ON_TIME</name>
              <description>[5:1] Configuration (in number of 38.4 MHz clks) for the ON-Time in generation of ADC_CLK</description>
              <bitWidth>5</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_GPIO_WAKE_CONF</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>APPS_GPIO_WAKE_CONF</description>
          <fields>
            <field>
              <name>APPS_GPIO_WAKE_CONF</name>
              <description>[1:0] &amp;quot;00&amp;quot; - Wake on Level0 on selected GPIO pin (GPIO is selected inside the HIB3p3 module); &amp;quot;01&amp;quot; - Wakeup on fall-edge of GPIO pin.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN_NWP_BOOT_WO_DEVINIT</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>EN_NWP_BOOT_WO_DEVINIT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HCLK_DIV_CFG</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>MEM_HCLK_DIV_CFG</description>
          <fields>
            <field>
              <name>MEM_HCLK_DIV_CFG</name>
              <description>[2:0] Division configuration for HCLKDIVOUT : &amp;quot;000&amp;quot; - Divide by 1 ; &amp;quot;001&amp;quot; - Divide by 2 ; &amp;quot;010&amp;quot; - Divide by 3 ; &amp;quot;011&amp;quot; - Divide by 4 ; &amp;quot;100&amp;quot; - Divide by 5 ; &amp;quot;101&amp;quot; - Divide by 6 ; &amp;quot;110&amp;quot; - Divide by 7 ; &amp;quot;111&amp;quot; - Divide by 8</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_SYSCLK_DIV_CFG</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>MEM_SYSCLK_DIV_CFG</description>
          <fields>
            <field>
              <name>MEM_SYSCLK_DIV_OFF_TIME</name>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MEM_SYSCLK_DIV_ON_TIME</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_LOCK_TIME_CONF</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>APLLMCS_LOCK_TIME_CONF</description>
          <fields>
            <field>
              <name>MEM_APLLMCS_WLAN_LOCK_TIME</name>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MEM_APLLMCS_MCU_LOCK_TIME</name>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_SOFT_RESET</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>NWP_SOFT_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_LPDS_WAKEUP_CFG</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>NWP_LPDS_WAKEUP_CFG</description>
          <fields>
            <field>
              <name>NWP_LPDS_WAKEUP_CFG</name>
              <description>[7:0] Mask for LPDS Wakeup interrupt : 7 - WLAN Host Interrupt ; 6 - WLAN to NWP Wake request ; 5 - APPS to NWP Wake request; 4 - GPIO Wakeup ; 3 - Autonomous UART Wakeup ; 2 - SSDIO Wakeup ; 1 - Autonomous SPI Wakeup ; 0 - LPDS Wakeup-timer</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_LPDS_WAKEUP_SRC</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>NWP_LPDS_WAKEUP_SRC</description>
          <fields>
            <field>
              <name>NWP_LPDS_WAKEUP_SRC</name>
              <description>[7:0] Indicates the cause for NWP LPDS-Wakeup : 7 - WLAN Host Interrupt ; 6 - WLAN to NWP Wake request ; 5 - APPS to NWP Wake request; 4 - GPIO Wakeup ; 3 - Autonomous UART Wakeup ; 2 - SSDIO Wakeup ; 1 - Autonomous SPI Wakeup ; 0 - LPDS Wakeup-timer</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_RESET_CAUSE</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>NWP_RESET_CAUSE</description>
          <fields>
            <field>
              <name>NWP_RESET_CAUSE</name>
              <description>[7:0] Indicates the reset cause for NWP : &amp;quot;0000&amp;quot; - Wake from HIB/OFF mode; &amp;quot;0001&amp;quot; - Wake from LPDS ; &amp;quot;0010&amp;quot; - Reserved ; &amp;quot;0011&amp;quot; - Soft-reset0 (Only NWP Cortex-sysrstn is asserted); &amp;quot;0100&amp;quot; - Soft-reset1 (NWP Cortex-sysrstn and NWP peripherals are reset); &amp;quot;0101&amp;quot; - WDOG0 (NWP Cortex-sysrstn and NWP peripherals are reset); &amp;quot;0110&amp;quot; - MCU Soft-reset (APPS + NWP Cortex-sysrstn + Peripherals are reset); &amp;quot;0111&amp;quot; - SSDIO Function2 reset (Only Cortex-sysrstn is asserted) ; &amp;quot;1000&amp;quot; - Reset due to WDOG of APPS (NWP Cortex-sysrstn and NWP peripherals are reset);</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_LPDS_WAKETIME_OPP_CFG</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>NWP_LPDS_WAKETIME_OPP_CFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_SRAM_DSLP_CFG</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>NWP_SRAM_DSLP_CFG</description>
          <fields>
            <field>
              <name>NWP_SRAM_DSLP_CFG</name>
              <description>[19:0] Configuration of NWP Memories during DSLP : 0 - SRAMs are OFF ; 1 - SRAMs are Retained. NWP SRAM Cluster information : [2] - 3rd column in MEMSS (Applicable only when owned by NWP) ; [3] - 4th column in MEMSS (Applicable only when owned by NWP) ; [4] - 5th column in MEMSS (Applicable only when owned by NWP) ; [5] - 6th column in MEMSS (Applicable only when owned by NWP) ; [6] - 7th column in MEMSS (Applicable only when owned by NWP) ; [7] - 8th column in MEMSS (Applicable only when owned by NWP) ; [8] - 9th column in MEMSS (Applicable only when owned by NWP) ; [9] - 10th column in MEMSS (Applicable only when owned by NWP) ; [10] - 11th column in MEMSS (Applicable only when owned by NWP) ; [11] - 12th column in MEMSS (Applicable only when owned by NWP) ; [12] - 13th column in MEMSS (Applicable only when owned by NWP) ; [13] - 14th column in MEMSS (Applicable only when owned by NWP) ; [14] - 15th column in MEMSS (Applicable only when owned by NWP) ; [19:18] - Reserved.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_SRAM_LPDS_CFG</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>NWP_SRAM_LPDS_CFG</description>
          <fields>
            <field>
              <name>NWP_SRAM_LPDS_CFG</name>
              <description>[19:0] Configuration of NWP Memories during LPDS : 0 - SRAMs are OFF ; 1 - SRAMs are Retained. NWP SRAM Cluster information : [2] - 3rd column in MEMSS (Applicable only when owned by NWP) ; [3] - 4th column in MEMSS (Applicable only when owned by NWP) ; [4] - 5th column in MEMSS (Applicable only when owned by NWP) ; [5] - 6th column in MEMSS (Applicable only when owned by NWP) ; [6] - 7th column in MEMSS (Applicable only when owned by NWP) ; [7] - 8th column in MEMSS (Applicable only when owned by NWP) ; [8] - 9th column in MEMSS (Applicable only when owned by NWP) ; [9] - 10th column in MEMSS (Applicable only when owned by NWP) ; [10] - 11th column in MEMSS (Applicable only when owned by NWP) ; [11] - 12th column in MEMSS (Applicable only when owned by NWP) ; [12] - 13th column in MEMSS (Applicable only when owned by NWP) ; [13] - 14th column in MEMSS (Applicable only when owned by NWP) ; [14] - 15th column in MEMSS (Applicable only when owned by NWP) ; [19:18] - Reserved.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_LPDS_WAKETIME_WAKE_CFG</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>NWP_LPDS_WAKETIME_WAKE_CFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_AUTONMS_SPI_MASTER_SEL</name>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <description>NWP_AUTONMS_SPI_MASTER_SEL</description>
          <fields>
            <field>
              <name>F</name>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_AUTONMS_SPI_IDLE_REQ</name>
          <addressOffset>0x428</addressOffset>
          <size>32</size>
          <description>NWP_AUTONMS_SPI_IDLE_REQ</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WLAN_TO_NWP_WAKE_REQUEST</name>
          <addressOffset>0x42C</addressOffset>
          <size>32</size>
          <description>WLAN_TO_NWP_WAKE_REQUEST</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_TO_WLAN_WAKE_REQUEST</name>
          <addressOffset>0x430</addressOffset>
          <size>32</size>
          <description>NWP_TO_WLAN_WAKE_REQUEST</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_GPIO_WAKE_CONF</name>
          <addressOffset>0x434</addressOffset>
          <size>32</size>
          <description>NWP_GPIO_WAKE_CONF</description>
          <fields>
            <field>
              <name>NWP_GPIO_WAKE_CONF</name>
              <description>[1:0] &amp;quot;00&amp;quot; - Wakeup on level0 of the selected GPIO (GPIO gets selected inside HIB3P3-module); &amp;quot;01&amp;quot; - Wakeup on fall-edge of selected GPIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG12</name>
          <addressOffset>0x438</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG12</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIEID_READ_REG5</name>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <description>DIEID_READ_REG5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIEID_READ_REG6</name>
          <addressOffset>0x44C</addressOffset>
          <size>32</size>
          <description>DIEID_READ_REG6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_FSM_CFG0</name>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <description>REF_FSM_CFG0</description>
          <fields>
            <field>
              <name>BGAP_SETTLING_TIME</name>
              <description>[23:16] ANA-BGAP Settling time (In number of slow_clks)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>FREF_LDO_SETTLING_TIME</name>
              <description>[15:8] Slicer LDO settling time (In number of slow clks)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIG_BUF_SETTLING_TIME</name>
              <description>[7:0] Dig-buffer settling time (In number of slow clks)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_FSM_CFG1</name>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <description>REF_FSM_CFG1</description>
          <fields>
            <field>
              <name>XTAL_SETTLING_TIME</name>
              <description>[31:24] XTAL settling time (In number of slow clks)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SLICER_LV_SETTLING_TIME</name>
              <description>[23:16] LV Slicer settling time</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SLICER_HV_PD_SETTLING_TIME</name>
              <description>[15:8] HV Slicer Pull-down settling time</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SLICER_HV_SETTLING_TIME</name>
              <description>[7:0] HV Slicer settling time</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_WLAN_CONFIG0_40</name>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <description>APLLMCS_WLAN_CONFIG0_40</description>
          <fields>
            <field>
              <name>APLLMCS_WLAN_N_40</name>
              <description>[14:8] Configuration for WLAN APLLMCS - N[6:0], if the XTAL frequency is 40 MHz (Selected by efuse)</description>
              <bitWidth>7</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>APLLMCS_WLAN_M_40</name>
              <description>[7:0] Configuration for WLAN APLLMCS - M[7:0], if the XTAL frequency is 40 MHz (Selected by efuse)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_WLAN_CONFIG1_40</name>
          <addressOffset>0x80C</addressOffset>
          <size>32</size>
          <description>APLLMCS_WLAN_CONFIG1_40</description>
          <fields>
            <field>
              <name>APLLMCS_SELINPFREQ_40</name>
              <description>[2:0] Configuration for WLAN APLLMCS - Selinpfreq, if the XTAL frequency is 40 MHz (Selected by Efuse)</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_WLAN_CONFIG0_26</name>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <description>APLLMCS_WLAN_CONFIG0_26</description>
          <fields>
            <field>
              <name>APLLMCS_WLAN_N_26</name>
              <description>[14:8] Configuration for WLAN APLLMCS - N[6:0], if the XTAL frequency is 26 MHz (Selected by efuse)</description>
              <bitWidth>7</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>APLLMCS_WLAN_M_26</name>
              <description>[7:0] Configuration for WLAN APLLMCS - M[7:0], if the XTAL frequency is 26 MHz (Selected by efuse)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_WLAN_CONFIG1_26</name>
          <addressOffset>0x814</addressOffset>
          <size>32</size>
          <description>APLLMCS_WLAN_CONFIG1_26</description>
          <fields>
            <field>
              <name>APLLMCS_SELINPFREQ_26</name>
              <description>[2:0] Configuration for WLAN APLLMCS - Selinpfreq, if the XTAL frequency is 26 MHz (Selected by Efuse)</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_WLAN_OVERRIDES</name>
          <addressOffset>0x818</addressOffset>
          <size>32</size>
          <description>APLLMCS_WLAN_OVERRIDES</description>
          <fields>
            <field>
              <name>APLLMCS_WLAN_POSTDIV_OVERRIDE</name>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>APLLMCS_WLAN_SPARE</name>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>APLLMCS_WLAN_N_7_8_OVERRIDE</name>
              <description>[1:0] Override value for WLAN_APLLMCS_N[8:7] bits. Applicable only when bit [1] is set to 1. (Else controlled from WTOP)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_MCU_RUN_CONFIG0_38P4</name>
          <addressOffset>0x81C</addressOffset>
          <size>32</size>
          <description>APLLMCS_MCU_RUN_CONFIG0_38P4</description>
          <fields>
            <field>
              <name>APLLMCS_MCU_POSTDIV</name>
              <bitWidth>3</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>APLLMCS_MCU_SPARE</name>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>APLLMCS_MCU_RUN_N_38P4</name>
              <description>[22:16] Configuration for MCU-APLLMCS : N during RUN mode. Selected if the XTAL frequency is 38.4 MHz (from Efuse)</description>
              <bitWidth>7</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>APLLMCS_MCU_RUN_M_38P4</name>
              <description>[15:8] Configuration for MCU-APLLMCS : M during RUN mode. Selected if the XTAL frequency is 38.4 MHz (from Efuse)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>APLLMCS_MCU_RUN_N_7_8_38P4</name>
              <description>[1:0] Configuration for MCU-APLLMCS : N[8:7] during RUN mode. Selected if the XTAL frequency is 38.4 MHz (From Efuse)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_MCU_RUN_CONFIG1_38P4</name>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <description>APLLMCS_MCU_RUN_CONFIG1_38P4</description>
          <fields>
            <field>
              <name>APLLMCS_MCU_RUN_SELINPFREQ_38P4</name>
              <description>[2:0] Configuration for MCU-APLLMCS : SELINPFREQ during RUN mode. Selected if the XTAL frequency is 38.4 MHz (from Efuse)</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_MCU_RUN_CONFIG0_26</name>
          <addressOffset>0x824</addressOffset>
          <size>32</size>
          <description>APLLMCS_MCU_RUN_CONFIG0_26</description>
          <fields>
            <field>
              <name>APLLMCS_MCU_RUN_N_26</name>
              <description>[22:16] Configuration for MCU-APLLMCS : N during RUN mode. Selected if the XTAL frequency is 26 MHz (from Efuse)</description>
              <bitWidth>7</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>APLLMCS_MCU_RUN_M_26</name>
              <description>[15:8] Configuration for MCU-APLLMCS : M during RUN mode. Selected if the XTAL frequency is 26 MHz (from Efuse)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>APLLMCS_MCU_RUN_N_7_8_26</name>
              <description>[1:0] Configuration for MCU-APLLMCS : N[8:7] during RUN mode. Selected if the XTAL frequency is 26 MHz (From Efuse)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_MCU_RUN_CONFIG1_26</name>
          <addressOffset>0x828</addressOffset>
          <size>32</size>
          <description>APLLMCS_MCU_RUN_CONFIG1_26</description>
          <fields>
            <field>
              <name>APLLMCS_MCU_RUN_SELINPFREQ_26</name>
              <description>[2:0] Configuration for MCU-APLLMCS : SELINPFREQ during RUN mode. Selected if the XTAL frequency is 26 MHz (from Efuse)</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_RW0</name>
          <addressOffset>0x82C</addressOffset>
          <size>32</size>
          <description>SPARE_RW0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_RW1</name>
          <addressOffset>0x830</addressOffset>
          <size>32</size>
          <description>SPARE_RW1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APLLMCS_MCU_OVERRIDES</name>
          <addressOffset>0x834</addressOffset>
          <size>32</size>
          <description>APLLMCS_MCU_OVERRIDES</description>
          <fields>
            <field>
              <name>SYSCLK_SRC_OVERRIDE</name>
              <description>[2:1] Override for sysclk src (applicable only if bit [0] is set to 1. &amp;quot;00&amp;quot;- SLOW_CLK &amp;quot;01&amp;quot;- XTAL_CLK &amp;quot;10&amp;quot;- PLL_CLK</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCLK_SWITCH_STATUS</name>
          <addressOffset>0x838</addressOffset>
          <size>32</size>
          <description>SYSCLK_SWITCH_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_LDO_CONTROLS</name>
          <addressOffset>0x83C</addressOffset>
          <size>32</size>
          <description>REF_LDO_CONTROLS</description>
          <fields>
            <field>
              <name>REF_SPARE_CONTROL</name>
              <description>[15:14] Spare bits for REF_CTRL_FSM. Reaches directly on port TOP_PM_REG2[15:14] of gprcm.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>REF_TLOAD_ENABLE</name>
              <description>[13:11] REF TLOAD Enable. Reaches directly on port TOP_PM_REG2[13:11] of gprcm.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>REF_LDO_TMUX_CONTROL</name>
              <description>[10:8] REF_LDO Test-mux control. Reaches directly on port TOP_PM_REG2[10:8] of gprcm.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>REF_BW_CONTROL</name>
              <description>[7:6] REF BW Control. Reaches directly on port TOP_PM_REG2[7:6] of gprcm.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>REF_VTRIM_CONTROL</name>
              <description>[5:2] REF VTRIM Control. Reaches directly on port TOP_PM_REG2[5:2] of gprcm.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_RTRIM_CONTROL</name>
          <addressOffset>0x840</addressOffset>
          <size>32</size>
          <description>REF_RTRIM_CONTROL</description>
          <fields>
            <field>
              <name>TOP_PM_REG0_5_4</name>
              <description>[28:27] This is [5:4] bits of TOP_PM_REG0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>TOP_CLKM_REG0_15_5</name>
              <description>[26:16] This is [15:5] bits of TOP_CLKM_REG0</description>
              <bitWidth>11</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>REF_CLKM_RTRIM</name>
              <description>[4:0] CLKM_TRIM Override. Applicable when efuse_done = 0 or bit[8] is set to 1.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_SLICER_CONTROLS0</name>
          <addressOffset>0x844</addressOffset>
          <size>32</size>
          <description>REF_SLICER_CONTROLS0</description>
          <fields>
            <field>
              <name>CM_TMUX_SEL_LOWV</name>
              <description>[9:6] CM Test-mux select. Reaches on TOP_CLMM_REG1_IN[9:6] port of gprcm</description>
              <bitWidth>4</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLICER_SPARE0</name>
              <description>[5:4] Slicer spare0 control. Reaches on TOP_CLKM_REG1_IN[5:4] port of gprcm</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_SLICER_CONTROLS1</name>
          <addressOffset>0x848</addressOffset>
          <size>32</size>
          <description>REF_SLICER_CONTROLS1</description>
          <fields>
            <field>
              <name>SLICER_SPARE1</name>
              <description>[15:10] Slicer spare1. Reaches on port TOP_CLKM_REG2_IN[15:10] of gprcm.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>XOSC_TRIM</name>
              <description>[9:4] XOSC Trim. Reaches on port TOP_CLKM_REG2_IN[9:4] of gprcm</description>
              <bitWidth>6</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SLICER_LV_TRIM</name>
              <description>[2:0] LV Slicer trim. Reaches on port TOP_CLKM_REG2_IN[2:0] of gprcm.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_ANA_BGAP_CONTROLS0</name>
          <addressOffset>0x84C</addressOffset>
          <size>32</size>
          <description>REF_ANA_BGAP_CONTROLS0</description>
          <fields>
            <field>
              <name>MEM_REF_TEMP_TRIM</name>
              <description>[15:10] REF_TEMP_TRIM override. Applicable when bit [20] of this register set to 1. (or efc_done = 0) Note : Final REF_TEMP_TRIM reaches on port TOP_PM_REG0[15:10] of gprcm.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MEM_REF_V2I_TRIM</name>
              <description>[9:6] REF_V2I_TRIM Override. Applicable when bit [21] of this register set to 1 . (of efc_done = 0) Note : Final REF_V2I_TRIM reaches on port TOP_PM_REG0[9:6] of gprcm.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>NU1</name>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_ANA_BGAP_CONTROLS1</name>
          <addressOffset>0x850</addressOffset>
          <size>32</size>
          <description>REF_ANA_BGAP_CONTROLS1</description>
          <fields>
            <field>
              <name>MEM_REF_BG_SPARE</name>
              <description>[15:14] REF_BGAP_SPARE. Reaches on port TOP_PM_REG1[15:14] of gprcm.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>MEM_REF_BGAP_TMUX_CTRL</name>
              <description>[13:9] REF_BGAP_TMUX_CTRL. Reaches on port TOP_PM_REG1[13:9] of gprcm.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>MEM_REF_FILT_TRIM</name>
              <description>[8:5] REF_FILT_TRIM. Reaches on port TOP_PM_REG1[8:5] of gprcm.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MEM_REF_MAG_TRIM</name>
              <description>[4:0] REF_MAG_TRIM Override. Applicable when bit[22] of REF_ANA_BGAP_CONTROLS0 [0x084C] set to 1 (of efc_done = 0). Note : Final REF_MAG_TRIM reaches on port TOP_PM_REG1[4:0] of gprcm</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_ANA_SPARE_CONTROLS0</name>
          <addressOffset>0x854</addressOffset>
          <size>32</size>
          <description>REF_ANA_SPARE_CONTROLS0</description>
          <fields>
            <field>
              <name>MEM_TOP_PM_REG3</name>
              <description>[15:0] Spare control. Reaches on TOP_PM_REG3 [15:0] of gprcm.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_ANA_SPARE_CONTROLS1</name>
          <addressOffset>0x858</addressOffset>
          <size>32</size>
          <description>REF_ANA_SPARE_CONTROLS1</description>
          <fields>
            <field>
              <name>MEM_TOP_CLKM_REG3</name>
              <description>[31:16] Spare control. Reaches on TOP_CLKM_REG3 [15:0] of gprcm.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_TOP_CLKM_REG4</name>
              <description>[15:0] Spare control. Reaches on TOP_CLKM_REG4 [15:0] of gprcm.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEMSS_PSCON_OVERRIDES0</name>
          <addressOffset>0x85C</addressOffset>
          <size>32</size>
          <description>MEMSS_PSCON_OVERRIDES0</description>
          <fields>
            <field>
              <name>MEM_MEMSS_PSCON_MEM_OFF_OVERRIDE</name>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_MEMSS_PSCON_MEM_RETAIN_OVERRIDE</name>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEMSS_PSCON_OVERRIDES1</name>
          <addressOffset>0x860</addressOffset>
          <size>32</size>
          <description>MEMSS_PSCON_OVERRIDES1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PLL_REF_LOCK_OVERRIDES</name>
          <addressOffset>0x864</addressOffset>
          <size>32</size>
          <description>PLL_REF_LOCK_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCU_PSCON_DEBUG</name>
          <addressOffset>0x868</addressOffset>
          <size>32</size>
          <description>MCU_PSCON_DEBUG</description>
          <fields>
            <field>
              <name>MCU_PSCON_RTC_PS</name>
              <description>[5:3] MCU_PSCON_RTC_ON = &amp;quot;0000&amp;quot;; MCU_PSCON_RTC_OFF = &amp;quot;0001&amp;quot;; MCU_PSCON_RTC_RET = &amp;quot;0010&amp;quot;; MCU_PSCON_RTC_OFF_TO_ON = &amp;quot;0011&amp;quot;; MCU_PSCON_RTC_RET_TO_ON = &amp;quot;0100&amp;quot;; MCU_PSCON_RTC_ON_TO_RET = &amp;quot;0101&amp;quot;; MCU_PSCON_RTC_ON_TO_OFF = &amp;quot;0110&amp;quot;; MCU_PSCON_RTC_RET_TO_ON_WAIT_OPP = &amp;quot;0111&amp;quot;; MCU_PSCON_RTC_OFF_TO_ON_WAIT_OPP = &amp;quot;1000&amp;quot;;</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MCU_PSCON_SYS_PS</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEMSS_PWR_PS</name>
          <addressOffset>0x86C</addressOffset>
          <size>32</size>
          <description>MEMSS_PWR_PS</description>
          <fields>
            <field>
              <name>PWR_PS_MEMSS</name>
              <description>[2:0] MEMSS_PM_SLEEP = &amp;quot;000&amp;quot;; MEMSS_PM_WAIT_OPP = &amp;quot;010&amp;quot;; MEMSS_PM_ACTIVE = &amp;quot;011&amp;quot;; MEMSS_PM_SLEEP_TO_ACTIVE = &amp;quot;100&amp;quot;; MEMSS_PM_ACTIVE_TO_SLEEP = &amp;quot;101&amp;quot;;</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REF_FSM_DEBUG</name>
          <addressOffset>0x870</addressOffset>
          <size>32</size>
          <description>REF_FSM_DEBUG</description>
          <fields>
            <field>
              <name>FREF_MODE</name>
              <description>[5:4] 01 - HV Mode ; 10 - LV Mode ; 11 - XTAL Mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>REF_FSM_PS</name>
              <description>[3:0] constant FREF_CLK_OFF = &amp;quot;00000&amp;quot;; constant FREF_EN_BGAP = &amp;quot;00001&amp;quot;; constant FREF_EN_LDO = &amp;quot;00010&amp;quot;; constant FREF_EN_SLI_HV = &amp;quot;00011&amp;quot;; constant FREF_EN_SLI_HV_PD = &amp;quot;00100&amp;quot;; constant FREF_EN_DIG_BUF = &amp;quot;00101&amp;quot;; constant FREF_EN_OSC = &amp;quot;00110&amp;quot;; constant FREF_EN_SLI_LV = &amp;quot;00111&amp;quot;; constant FREF_EN_CLK_REQ = &amp;quot;01000&amp;quot;; constant FREF_CLK_VALID = &amp;quot;01001&amp;quot;; constant FREF_MODE_DET0 = &amp;quot;01010&amp;quot;; constant FREF_MODE_DET1 = &amp;quot;01011&amp;quot;; constant FREF_MODE_DET2 = &amp;quot;10010&amp;quot;; constant FREF_MODE_DET3 = &amp;quot;10011&amp;quot;; constant FREF_VALID = &amp;quot;01100&amp;quot;; constant FREF_VALID0 = &amp;quot;01101&amp;quot;; constant FREF_VALID1 = &amp;quot;01110&amp;quot;; constant FREF_VALID2 = &amp;quot;01111&amp;quot;; constant FREF_WAIT_EXT_TCXO0 = &amp;quot;10000&amp;quot;; constant FREF_WAIT_EXT_TCXO1 = &amp;quot;10001&amp;quot;;</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_SYS_OPP_REQ_OVERRIDE</name>
          <addressOffset>0x874</addressOffset>
          <size>32</size>
          <description>MEM_SYS_OPP_REQ_OVERRIDE</description>
          <fields>
            <field>
              <name>MEM_SYS_OPP_REQ_OVERRIDE</name>
              <description>[3:0] &amp;quot;0001&amp;quot; - RUN ; &amp;quot;0010&amp;quot; - DSLP ; &amp;quot;0100&amp;quot; - LPDS ; Others - NA</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_TESTCTRL_PD_OPP_CONFIG</name>
          <addressOffset>0x878</addressOffset>
          <size>32</size>
          <description>MEM_TESTCTRL_PD_OPP_CONFIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_WL_FAST_CLK_REQ_OVERRIDES</name>
          <addressOffset>0x87C</addressOffset>
          <size>32</size>
          <description>MEM_WL_FAST_CLK_REQ_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_MCU_PD_MODE_REQ_OVERRIDES</name>
          <addressOffset>0x880</addressOffset>
          <size>32</size>
          <description>MEM_MCU_PD_MODE_REQ_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_MCSPI_SRAM_OFF_REQ_OVERRIDES</name>
          <addressOffset>0x884</addressOffset>
          <size>32</size>
          <description>MEM_MCSPI_SRAM_OFF_REQ_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_WLAN_APLLMCS_OVERRIDES</name>
          <addressOffset>0x888</addressOffset>
          <size>32</size>
          <description>MEM_WLAN_APLLMCS_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_REF_FSM_CFG2</name>
          <addressOffset>0x88C</addressOffset>
          <size>32</size>
          <description>MEM_REF_FSM_CFG2</description>
          <fields>
            <field>
              <name>MEM_FC_DEASSERT_DELAY</name>
              <description>[21:19] Number of RTC clocks for keeping the FC_EN asserted high</description>
              <bitWidth>3</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>MEM_STARTUP_DEASSERT_DELAY</name>
              <description>[18:16] Number of RTC clocks for keeping the STARTUP_EN asserted high</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_EXT_TCXO_SETTLING_TIME</name>
              <description>[15:0] Number of RTC clocks for waiting for clock to settle.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TESTCTRL_POWER_CTRL</name>
          <addressOffset>0xC10</addressOffset>
          <size>32</size>
          <description>TESTCTRL_POWER_CTRL</description>
          <fields>
            <field>
              <name>TESTCTRL_PD_STATUS</name>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSDIO_POWER_CTRL</name>
          <addressOffset>0xC14</addressOffset>
          <size>32</size>
          <description>SSDIO_POWER_CTRL</description>
          <fields>
            <field>
              <name>SSDIO_PD_STATUS</name>
              <description>[2:1] 1 - SSDIO-PD is ON ; 0 - SSDIO-PD is OFF</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_N1_POWER_CTRL</name>
          <addressOffset>0xC18</addressOffset>
          <size>32</size>
          <description>MCSPI_N1_POWER_CTRL</description>
          <fields>
            <field>
              <name>MCSPI_N1_PD_STATUS</name>
              <description>[2:1] 1 - MCSPI_N1-PD is ON ; 0 - MCSPI_N1-PD if OFF</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WELP_POWER_CTRL</name>
          <addressOffset>0xC1C</addressOffset>
          <size>32</size>
          <description>WELP_POWER_CTRL</description>
          <fields>
            <field>
              <name>WTOP_PD_STATUS</name>
              <bitWidth>3</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>WELP_PD_STATUS</name>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WL_SDIO_POWER_CTRL</name>
          <addressOffset>0xC20</addressOffset>
          <size>32</size>
          <description>WL_SDIO_POWER_CTRL</description>
          <fields>
            <field>
              <name>WL_SDIO_PD_STATUS</name>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WLAN_SRAM_ACTIVE_PWR_CFG</name>
          <addressOffset>0xC24</addressOffset>
          <size>32</size>
          <description>WLAN_SRAM_ACTIVE_PWR_CFG</description>
          <fields>
            <field>
              <name>WLAN_SRAM_ACTIVE_PWR_CFG</name>
              <description>[23:0] SRAM (WTOP+DRP) state during Active-mode : 1 - SRAMs are ON ; 0 - SRAMs are OFF. Cluster information : [0] - 1st column of MEMSS (Applicable only when owned by WTOP/PHY) [1] - 2nd column of MEMSS (Applicable only when owned by WTOP/PHY) ; [2] - 3rd column of MEMSS (Applicable only when owned by WTOP/PHY) ; [3] - 4th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [4] - 5th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [5] - 6th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [6] - 7th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [7] - 8th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [8] - 9th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [9] - 10th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [10] - 11th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [11] - 12th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [12] - 13th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [13] - 14th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [14] - 15th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [15] - 16th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [23:16] - Internal to WTOP Cluster</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WLAN_SRAM_SLEEP_PWR_CFG</name>
          <addressOffset>0xC28</addressOffset>
          <size>32</size>
          <description>WLAN_SRAM_SLEEP_PWR_CFG</description>
          <fields>
            <field>
              <name>WLAN_SRAM_SLEEP_PWR_CFG</name>
              <description>[23:0] SRAM (WTOP+DRP) state during Sleep-mode : 1 - SRAMs are RET ; 0 - SRAMs are OFF. Cluster information : [0] - 1st column of MEMSS (Applicable only when owned by WTOP/PHY) [1] - 2nd column of MEMSS (Applicable only when owned by WTOP/PHY) ; [2] - 3rd column of MEMSS (Applicable only when owned by WTOP/PHY) ; [3] - 4th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [4] - 5th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [5] - 6th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [6] - 7th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [7] - 8th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [8] - 9th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [9] - 10th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [10] - 11th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [11] - 12th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [12] - 13th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [13] - 14th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [14] - 15th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [15] - 16th column of MEMSS (Applicable only when owned by WTOP/PHY) ; [23:16] - Internal to WTOP Cluster</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SECURE_INIT_DONE</name>
          <addressOffset>0xC30</addressOffset>
          <size>32</size>
          <description>APPS_SECURE_INIT_DONE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_DEV_MODE_INIT_DONE</name>
          <addressOffset>0xC34</addressOffset>
          <size>32</size>
          <description>APPS_DEV_MODE_INIT_DONE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN_APPS_REBOOT</name>
          <addressOffset>0xC38</addressOffset>
          <size>32</size>
          <description>EN_APPS_REBOOT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_APPS_PERIPH_PRESENT</name>
          <addressOffset>0xC3C</addressOffset>
          <size>32</size>
          <description>MEM_APPS_PERIPH_PRESENT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_NWP_PERIPH_PRESENT</name>
          <addressOffset>0xC40</addressOffset>
          <size>32</size>
          <description>MEM_NWP_PERIPH_PRESENT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_SHARED_PERIPH_PRESENT</name>
          <addressOffset>0xC44</addressOffset>
          <size>32</size>
          <description>MEM_SHARED_PERIPH_PRESENT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_PWR_STATE</name>
          <addressOffset>0xC48</addressOffset>
          <size>32</size>
          <description>NWP_PWR_STATE</description>
          <fields>
            <field>
              <name>NWP_PWR_STATE_PS</name>
              <description>[11:8] &amp;quot;0000&amp;quot;- PORZ :- NWP is yet to be enabled by APPS during powerup (from HIB/OFF) ; &amp;quot;0011&amp;quot;- ACTIVE :- NWP is enabled, clocks and resets to NWP-SubSystem are enabled ; &amp;quot;0010&amp;quot;- LPDS :- NWP is in LPDS-mode ; Clocks and reset to NWP-SubSystem are gated ; &amp;quot;0101&amp;quot;- WAIT_FOR_OPP :- NWP is in transition from LPDS to ACTIVE, where it is waiting for OPP to be stable ; &amp;quot;1000&amp;quot;- WAKE_TIMER_OPP_REQ :- NWP is in transition from LPDS, where the wakeup cause is LPDS_Wake timer OTHERS : NA</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NWP_RCM_PS</name>
              <description>[2:0] &amp;quot;000&amp;quot; - NWP_RUN : NWP is in RUN state (default) - Applicable only when NWP_PWR_STATE_PS = ACTIVE ; &amp;quot;001&amp;quot; - NWP_SLP : NWP is in SLEEP state (default) - Applicable only when NWP_PWR_STATE_PS = ACTIVE ; &amp;quot;010&amp;quot; - NWP_DSLP : NWP is in Deep-Sleep state (default) - Applicable only when NWP_PWR_STATE_PS = ACTIVE ; &amp;quot;011&amp;quot; - WAIT_FOR_ACTIVE : NWP is in transition from Deep-sleep to Run, where it is waiting for OPP to be stable ; &amp;quot;100&amp;quot; - WAIT_FOR_DSLP_TIMER_WAKE_REQ : NWP is in transition from Deep-sleep to Run, where the wakeup cause is deep-sleep wake-timer</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_PWR_STATE</name>
          <addressOffset>0xC4C</addressOffset>
          <size>32</size>
          <description>APPS_PWR_STATE</description>
          <fields>
            <field>
              <name>APPS_PWR_STATE_PS</name>
              <description>[11:8] &amp;quot;0000&amp;quot;- PORZ :- APPS is waiting for PLL_clock during powerup (from HIB/OFF) ; &amp;quot;0011&amp;quot;- ACTIVE :- APPS is enabled, clocks and resets to APPS-SubSystem are enabled ; APPS might be either in Secure or Un-secure mode during this state. &amp;quot;1001&amp;quot; - SECURE_MODE_LPDS :- While in ACTIVE (Secure-mode), APPS had to program the DevInit_done bit at the end, after which it enters into this state, where the reset to APPS will be asserted. From this state APPS might either re-boot itself or enter into LPDS depending upon whether the device is 3200 or 3100. &amp;quot;0010&amp;quot;- LPDS :- APPS is in LPDS-mode ; Clocks and reset to APPS-SubSystem are gated ; &amp;quot;0101&amp;quot;- WAIT_FOR_OPP :- APPS is in transition from LPDS to ACTIVE, where it is waiting for OPP to be stable ; &amp;quot;1000&amp;quot; - WAKE_TIMER_OPP_REQ : APPS is in transition from LPDS, where the wakeup cause is LPDS_Wake timer ; &amp;quot;1010&amp;quot; - WAIT_FOR_PATCH_INIT : APPS enters into this state during development-mode #3 (SOP = 3), where it is waiting for patch download to complete and 0x4 hack is programmed. OTHERS : NA</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>APPS_RCM_PS</name>
              <description>[2:0] &amp;quot;000&amp;quot; - APPS_RUN : APPS is in RUN state (default) - Applicable only when APPS_PWR_STATE_PS = ACTIVE ; &amp;quot;001&amp;quot; - APPS_SLP : APPS is in SLEEP state (default) - Applicable only when APPS_PWR_STATE_PS = ACTIVE ; &amp;quot;010&amp;quot; - APPS_DSLP : APPS is in Deep-Sleep state (default) - Applicable only when APPS_PWR_STATE_PS = ACTIVE ; &amp;quot;011&amp;quot; - WAIT_FOR_ACTIVE : APPS is in transition from Deep-sleep to Run, where it is waiting for OPP to be stable ; &amp;quot;100&amp;quot; - WAIT_FOR_DSLP_TIMER_WAKE_REQ : APPS is in transition from Deep-sleep to Run, where the wakeup cause is deep-sleep wake-timer</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCU_PWR_STATE</name>
          <addressOffset>0xC50</addressOffset>
          <size>32</size>
          <description>MCU_PWR_STATE</description>
          <fields>
            <field>
              <name>MCU_OPP_PS</name>
              <description>[4:0] TBD</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WTOP_PM_PS</name>
          <addressOffset>0xC54</addressOffset>
          <size>32</size>
          <description>WTOP_PM_PS</description>
          <fields>
            <field>
              <name>WTOP_PM_PS</name>
              <description>[2:0] &amp;quot;011&amp;quot; - WTOP_PM_ACTIVE (Default) :- WTOP_Pd is in ACTIVE mode; &amp;quot;100&amp;quot; - WTOP_PM_ACTIVE_TO_SLEEP :- WTOP_Pd is in transition from ACTIVE to SLEEP ; &amp;quot;000&amp;quot; - WTOP_PM_SLEEP : WTOP-Pd is in Sleep-state ; &amp;quot;100&amp;quot; - WTOP_PM_SLEEP_TO_ACTIVE : WTOP_Pd is in transition from SLEEP to ACTIVE ; &amp;quot;000&amp;quot; - WTOP_PM_WAIT_FOR_OPP : Wait for OPP to be stable ;</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WTOP_PD_RESETZ_OVERRIDE_REG</name>
          <addressOffset>0xC58</addressOffset>
          <size>32</size>
          <description>WTOP_PD_RESETZ_OVERRIDE_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WELP_PD_RESETZ_OVERRIDE_REG</name>
          <addressOffset>0xC5C</addressOffset>
          <size>32</size>
          <description>WELP_PD_RESETZ_OVERRIDE_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WL_SDIO_PD_RESETZ_OVERRIDE_REG</name>
          <addressOffset>0xC60</addressOffset>
          <size>32</size>
          <description>WL_SDIO_PD_RESETZ_OVERRIDE_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSDIO_PD_RESETZ_OVERRIDE_REG</name>
          <addressOffset>0xC64</addressOffset>
          <size>32</size>
          <description>SSDIO_PD_RESETZ_OVERRIDE_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_N1_PD_RESETZ_OVERRIDE_REG</name>
          <addressOffset>0xC68</addressOffset>
          <size>32</size>
          <description>MCSPI_N1_PD_RESETZ_OVERRIDE_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TESTCTRL_PD_RESETZ_OVERRIDE_REG</name>
          <addressOffset>0xC6C</addressOffset>
          <size>32</size>
          <description>TESTCTRL_PD_RESETZ_OVERRIDE_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCU_PD_RESETZ_OVERRIDE_REG</name>
          <addressOffset>0xC70</addressOffset>
          <size>32</size>
          <description>MCU_PD_RESETZ_OVERRIDE_REG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG0</name>
          <addressOffset>0xC78</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG1</name>
          <addressOffset>0xC7C</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG2</name>
          <addressOffset>0xC80</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG3</name>
          <addressOffset>0xC84</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WTOP_MEM_RET_CFG</name>
          <addressOffset>0xC88</addressOffset>
          <size>32</size>
          <description>WTOP_MEM_RET_CFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>COEX_CLK_SWALLOW_CFG0</name>
          <addressOffset>0xC8C</addressOffset>
          <size>32</size>
          <description>COEX_CLK_SWALLOW_CFG0</description>
          <fields>
            <field>
              <name>Q_FACTOR</name>
              <description>[22:0] TBD</description>
              <bitWidth>23</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>COEX_CLK_SWALLOW_CFG1</name>
          <addressOffset>0xC90</addressOffset>
          <size>32</size>
          <description>COEX_CLK_SWALLOW_CFG1</description>
          <fields>
            <field>
              <name>P_FACTOR</name>
              <description>[19:0] TBD</description>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>COEX_CLK_SWALLOW_CFG2</name>
          <addressOffset>0xC94</addressOffset>
          <size>32</size>
          <description>COEX_CLK_SWALLOW_CFG2</description>
          <fields>
            <field>
              <name>CONSECUTIVE_SWALLOW</name>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>COEX_CLK_SWALLOW_ENABLE</name>
          <addressOffset>0xC98</addressOffset>
          <size>32</size>
          <description>COEX_CLK_SWALLOW_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DCDC_CLK_GEN_CONFIG</name>
          <addressOffset>0xC9C</addressOffset>
          <size>32</size>
          <description>DCDC_CLK_GEN_CONFIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG4</name>
          <addressOffset>0xCA0</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG5</name>
          <addressOffset>0xCA4</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG6</name>
          <addressOffset>0xCA8</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG7</name>
          <addressOffset>0xCAC</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG7</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG8</name>
          <addressOffset>0xCB0</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG8</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG9</name>
          <addressOffset>0xCB4</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG9</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG10</name>
          <addressOffset>0xCB8</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG10</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG11</name>
          <addressOffset>0xCBC</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG11</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIEID_READ_REG0</name>
          <addressOffset>0xCC0</addressOffset>
          <size>32</size>
          <description>DIEID_READ_REG0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIEID_READ_REG1</name>
          <addressOffset>0xCC4</addressOffset>
          <size>32</size>
          <description>DIEID_READ_REG1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIEID_READ_REG2</name>
          <addressOffset>0xCC8</addressOffset>
          <size>32</size>
          <description>DIEID_READ_REG2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIEID_READ_REG3</name>
          <addressOffset>0xCCC</addressOffset>
          <size>32</size>
          <description>DIEID_READ_REG3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIEID_READ_REG4</name>
          <addressOffset>0xCD0</addressOffset>
          <size>32</size>
          <description>DIEID_READ_REG4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_SS_OVERRIDES</name>
          <addressOffset>0xCD4</addressOffset>
          <size>32</size>
          <description>APPS_SS_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NWP_SS_OVERRIDES</name>
          <addressOffset>0xCD8</addressOffset>
          <size>32</size>
          <description>NWP_SS_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SHARED_SS_OVERRIDES</name>
          <addressOffset>0xCDC</addressOffset>
          <size>32</size>
          <description>SHARED_SS_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDMEM_CORE_RST_OVERRIDES</name>
          <addressOffset>0xCE0</addressOffset>
          <size>32</size>
          <description>IDMEM_CORE_RST_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TOP_DIE_FSM_OVERRIDES</name>
          <addressOffset>0xCE4</addressOffset>
          <size>32</size>
          <description>TOP_DIE_FSM_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCU_PSCON_OVERRIDES</name>
          <addressOffset>0xCE8</addressOffset>
          <size>32</size>
          <description>MCU_PSCON_OVERRIDES</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MEM_MCU_PSCON_MEM_OFF_OVERRIDE</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_MCU_PSCON_MEM_RETAIN_OVERRIDE</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WTOP_PSCON_OVERRIDES</name>
          <addressOffset>0xCEC</addressOffset>
          <size>32</size>
          <description>WTOP_PSCON_OVERRIDES</description>
          <fields>
            <field>
              <name>MEM_WTOP_PSCON_MEM_OFF_OVERRIDE</name>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MEM_WTOP_PSCON_MEM_RETAIN_OVERRIDE</name>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WELP_PSCON_OVERRIDES</name>
          <addressOffset>0xCF0</addressOffset>
          <size>32</size>
          <description>WELP_PSCON_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WL_SDIO_PSCON_OVERRIDES</name>
          <addressOffset>0xCF4</addressOffset>
          <size>32</size>
          <description>WL_SDIO_PSCON_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCSPI_PSCON_OVERRIDES</name>
          <addressOffset>0xCF8</addressOffset>
          <size>32</size>
          <description>MCSPI_PSCON_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSDIO_PSCON_OVERRIDES</name>
          <addressOffset>0xCFC</addressOffset>
          <size>32</size>
          <description>SSDIO_PSCON_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>OCP_SHARED</name>
      <baseAddress>0x4402E000</baseAddress>
      <registers>
        <register>
          <name>SEMAPHORE1</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>SEMAPHORE1</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE1</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE2</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>SEMAPHORE2</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE2</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE3</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>SEMAPHORE3</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE3</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE4</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>SEMAPHORE4</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE4</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE5</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>SEMAPHORE5</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE5</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE6</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>SEMAPHORE6</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE6</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE7</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>SEMAPHORE7</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE7</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE8</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>SEMAPHORE8</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE8</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE9</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>SEMAPHORE9</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE9</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE10</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>SEMAPHORE10</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE10</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE11</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>SEMAPHORE11</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE11</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORE12</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>SEMAPHORE12</description>
          <fields>
            <field>
              <name>MEM_SEMAPHORE12</name>
              <description>[1:0] General Purpose Semaphore for SW Usage. If any of the 2 bits of a given register is set to 1, it means that the semaphore is locked by one of the masters. Each bit represents a master IP as follows: {WLAN,NWP}. The JTAG cannot capture the semaphore but it can release it. As a master IP reads the semaphore, it will be caputed and the masters correlating bit will be set to 1 (set upon read). As any IP writes to this address (independent of the written data) the semaphore will be set to 2'b00.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IC_LOCKER_ID</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>IC_LOCKER_ID</description>
          <fields>
            <field>
              <name>MEM_IC_LOCKER_ID</name>
              <description>[2:0] This register is used for allowing only one master OCP to perform write transactions to the OCP slaves. Each bit represents an IP in the following format: { JTAG,WLAN, NWP mcu}. As any of the bits is set to one, the correlating IP is preventing the other IP's from performing write transactions to the slaves. As the Inter Connect is locked, the only the locking IP can write to the register and by that releasing the lock. 3'b000 => IC is not locked. 3'b001 => IC is locked by NWP mcu. 3'b010 => IC is locked by WLAN. 3'b100 => IC is locked by JTAG.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MCU_SEMAPHORE_PEND</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>MCU_SEMAPHORE_PEND</description>
          <fields>
            <field>
              <name>MEM_MCU_SEMAPHORE_PEND</name>
              <description>[15:0] This register specifies the semaphore for which the NWP mcu is waiting to be released. It is set to the serial number of a given locked semaphore after it was read by the NWP mcu. Only [11:0] is used.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WL_SEMAPHORE_PEND</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>WL_SEMAPHORE_PEND</description>
          <fields>
            <field>
              <name>MEM_WL_SEMAPHORE_PEND</name>
              <description>[15:0] This register specifies the semaphore for which the WLAN is waiting to be released. It is set to the serial number of a given locked semaphore after it was read by the WLAN. Only [11:0] is used.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PLATFORM_DETECTION_RD_ONLY</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>PLATFORM_DETECTION_RD_ONLY</description>
          <fields>
            <field>
              <name>PLATFORM_DETECTION</name>
              <description>[15:0] This information serves the IPs for knowing in which platform are they integrated at: 0 = CC31XX.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEMAPHORES_STATUS_RD_ONLY</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>SEMAPHORES_STATUS_RD_ONLY</description>
          <fields>
            <field>
              <name>SEMAPHORES_STATUS</name>
              <description>[11:0] Captured/released semaphores status for the 12 semaphores. Each bit of the 12 bits represents a semaphore. 0 => Semaphore Free. 1 => Semaphore Captured.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_CONFIG_CTRL</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>CC3XX_CONFIG_CTRL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_SHARED_MEM_SEL_LSB</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>CC3XX_SHARED_MEM_SEL_LSB</description>
          <fields>
            <field>
              <name>MEM_SHARED_MEM_SEL_LSB</name>
              <description>[29:0] This register provides memss RAM column configuration for column 0 to 9. 3 bits are allocated per column. This register is required to be configured before starting RAM access. Changing register setting while code is running will result into unpredictable memory behaviour. Register is supported to configured ones after core is booted up. 3 bit encoding per column is as follows: when 000 : WLAN, 001: NWP, 010: APPS, 011: PHY, 100: OCLA column 0 select: bit [2:0] :when 000 -> WLAN,001 -> NWP,010 -> APPS, 011 -> PHY, 100 -> OCLA column 1 select: bit [5:3] :column 2 select: bit [8 : 6]: column 3 select : bit [11: 9] column 4 select : bit [14:12] column 5 select : bit [17:15] column 6 select : bit [20:18] column 7 select : bit [23:21] column 8 select : bit [26:24] column 9 select : bit [29:27] column 10 select</description>
              <bitWidth>30</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_SHARED_MEM_SEL_MSB</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>CC3XX_SHARED_MEM_SEL_MSB</description>
          <fields>
            <field>
              <name>MEM_SHARED_MEM_SEL_MSB</name>
              <description>[11:0] This register provides memss RAM column configuration for column 10 to 15. 3 bits are allocated per column. This register is required to be configured before starting RAM access. Changing register setting while code is running will result into unpredictable memory behaviour. Register is supported to configured ones after core is booted up. 3 bit encoding per column is as follows: when 000 : WLAN, 001: NWP, 010: APPS, 011: PHY, 100: OCLA column 11 select : bit [2:0] column 12 select : bit [5:3] column 13 select : bit [8 : 6] column 14 select :</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WLAN_ELP_WAKE_EN</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>WLAN_ELP_WAKE_EN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEVINIT_ROM_START_ADDR</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>DEVINIT_ROM_START_ADDR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEVINIT_ROM_END_ADDR</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>DEVINIT_ROM_END_ADDR</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSBD_SEED</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>SSBD_SEED</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSBD_CHK</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>SSBD_CHK</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSBD_POLY_SEL</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>SSBD_POLY_SEL</description>
          <fields>
            <field>
              <name>MEM_SSBD_POLY_SEL</name>
              <description>[1:0] 2 bit, Writable only during devinit, and whole 2 bit should be output of the config register module.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_0</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>SPARE_REG_0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_1</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>SPARE_REG_1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_2</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>SPARE_REG_2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_3</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>SPARE_REG_3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_0</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_0</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_0</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; &amp;quot;For example in case of I2C Value gets latched at rising edge of RET33.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_1</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_1</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_1</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_2</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_2</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_2</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_3</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_3</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_3</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_4</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_4</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_4</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_5</name>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_5</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_5</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_6</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_6</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_6</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_7</name>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_7</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_7</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_8</name>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_8</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_8</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_9</name>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_9</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_9</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_10</name>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_10</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_10</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_11</name>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_11</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_11</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_12</name>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_12</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_12</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_13</name>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_13</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_13</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_14</name>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_14</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_14</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_15</name>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_15</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_15</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_16</name>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_16</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_16</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_17</name>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_17</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_17</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_18</name>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_18</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_18</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_19</name>
          <addressOffset>0xEC</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_19</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_19</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_20</name>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_20</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_20</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_21</name>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_21</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_21</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_22</name>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_22</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_22</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_23</name>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_23</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_23</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_24</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_24</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_24</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_25</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_25</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_25</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_26</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_26</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_26</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_27</name>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_27</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_27</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_28</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_28</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_28</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_29</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_29</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_29</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_30</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_30</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_30</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_31</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_31</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_31</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_32</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_32</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_32</name>
              <description>[11:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; it can be used for I2C type of peripherals. 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_33</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_33</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_33</name>
              <description>[5:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'. IODEN and I8MAEN is diesabled for all development IO's. These signals are tied to logic level '0'. common control is implemented for I2MAEN, I4MAEN, WKPU, WKPD control . refer dev_pad_cmn_config register bits.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_34</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_34</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_34</name>
              <description>[5:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'. IODEN and I8MAEN is diesabled for all development IO's. These signals are tied to logic level '0'. common control is implemented for I2MAEN, I4MAEN, WKPU, WKPD control . refer dev_pad_cmn_config register bits.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_35</name>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_35</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_35</name>
              <description>[5:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'. IODEN and I8MAEN is diesabled for all development IO's. These signals are tied to logic level '0'. common control is implemented for I2MAEN, I4MAEN, WKPU, WKPD control . refer dev_pad_cmn_config register bits.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_36</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_36</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_36</name>
              <description>[5:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'. IODEN and I8MAEN is diesabled for all development IO's. These signals are tied to logic level '0'. common control is implemented for I2MAEN, I4MAEN, WKPU, WKPD control . refer dev_pad_cmn_config register bits.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_37</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_37</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_37</name>
              <description>[5:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'. IODEN and I8MAEN is diesabled for all development IO's. These signals are tied to logic level '0'. common control is implemented for I2MAEN, I4MAEN, WKPU, WKPD control . refer dev_pad_cmn_config register bits.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_38</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_38</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_38</name>
              <description>[5:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'. IODEN and I8MAEN is diesabled for all development IO's. These signals are tied to logic level '0'. common control is implemented for I2MAEN, I4MAEN, WKPU, WKPD control . refer dev_pad_cmn_config register bits.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_39</name>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_39</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_39</name>
              <description>[5:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'. IODEN and I8MAEN is diesabled for all development IO's. These signals are tied to logic level '0'. common control is implemented for I2MAEN, I4MAEN, WKPU, WKPD control . refer dev_pad_cmn_config register bits.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CONFIG_40</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>GPIO_PAD_CONFIG_40</description>
          <fields>
            <field>
              <name>MEM_GPIO_PAD_CONFIG_40</name>
              <description>[18:0] GPIO 0 register: &amp;quot;Bit 0 - 3 is used for PAD IO mode selection. io_register={ &amp;quot;&amp;quot; 0 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[0]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 1 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[1]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 2 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[2]&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot; 3 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;CONFMODE[3]&amp;quot;&amp;quot;&amp;quot;&amp;quot; 4 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IODEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> When level 1 this disables the PMOS xtors of the output stages making them open-drain type.&amp;quot; &amp;quot;For example in case of I2C Value gets latched at rising edge of RET33.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 5 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I2MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 2mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 6 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I4MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 4mA output stage&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 7 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;I8MAEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> Level 1 enables the approx 8mA output stage. Note: any drive strength between 2mA and 14mA can be obtained with combination of 2mA 4mA and 8mA.&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 8 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPUEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull up (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 9 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IWKPDEN&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> 10uA pull down (weak strength)&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 10 => &amp;quot;&amp;quot;&amp;quot;&amp;quot;IOE_N&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable value. level 0 enables the IDO to PAD path. Else PAD is tristated (except for the PU/PD which are independent).&amp;quot; &amp;quot;Value gets latched at rising edge of RET33&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot; 11 =>&amp;quot;&amp;quot;&amp;quot;&amp;quot; IOE_N_OV&amp;quot;&amp;quot;&amp;quot;&amp;quot; --> output enable overirde. when bit is set to logic '1' IOE_N (bit 4) value will control IO IOE_N signal else IOE_N is control via selected HW logic. strong PULL UP and PULL Down control is disabled for all IO's. both controls are tied to logic level '0'.</description>
              <bitWidth>19</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIO_PAD_CMN_CONFIG</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>This register provide control to GPIO_CC3XXV1 IO PAD. Common control signals to all bottom Die IO's are controlled via this.</description>
          <fields>
            <field>
              <name>MEM_PAD_HYSTVAL</name>
              <description>[4:3] 00: hysteriris = 10% of VDDS (difference between upper and lower threshold of the schmit trigger) 01: hysteriris = 20% of VDDS (difference between upper and lower threshold of the schmit trigger) 10: hysteriris = 30% of VDDS (difference between upper and lower threshold of the schmit trigger) 11: hysteriris = 40% of VDDS (difference between upper and lower threshold of the schmit trigger)&amp;quot; &amp;quot;&amp;quot;&amp;quot;</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>D2D_DEV_PAD_CMN_CONFIG</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>D2D_DEV_PAD_CMN_CONFIG</description>
          <fields>
            <field>
              <name>MEM_DEV_PAD_CMN_CONF</name>
              <description>[5:0] this register implements common IO control to all devement mode PADs; these PADs are DEV_PAD33 to DEV_PAD39. Bit [1:0] : Drive strength control. These 2 bits are connected to DEV PAD drive strength control. possible drive stregnths are 2MA, 4MA and 6 MA for the these IO's. bit 0: when set to logic value '1' enable 2MA drive strength for DEVPAD01 to 07 bit 1: when set to logic value '1' enable 4MA drive strength for DEVPAD01 to 07. bit[3:2] : WK PULL UP and PULL down control. These 2 bits provide IWKPUEN and IWKPDEN control for all DEV IO's. bit 2: when set to logic value '1' enable WKPU to DEVPAD01 to 07 bit 3: when set to logic value '1' enable WKPD to DEVPAD01 to 07. bit 4: WK PULL control for DEV_PKG_DETECT pin. when '1' pullup enabled else it is disable. bit 5: when set to logic value '1' enable 8MA drive strength for DEVPAD01 to 07.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>D2D_TOSTACK_PAD_CONF</name>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <description>D2D_TOSTACK_PAD_CONF</description>
          <fields>
            <field>
              <name>MEM_D2D_TOSTACK_PAD_CONF</name>
              <description>[28:0] OEN/OEN2X control. When 0 : Act as input buffer else output buffer with drive strength 2. this register control OEN2X pin of D2D TOSTACK PAD: OEN1X and OEN2X decoding is as follows: &amp;quot;when &amp;quot;&amp;quot;00&amp;quot;&amp;quot; :&amp;quot; &amp;quot;when &amp;quot;&amp;quot;01&amp;quot;&amp;quot; : dirve strength is '1' and output buffer enabled.&amp;quot; &amp;quot;when &amp;quot;&amp;quot;10&amp;quot;&amp;quot; : drive strength is 2 and output buffer is disabled.&amp;quot; &amp;quot;when &amp;quot;&amp;quot;11&amp;quot;&amp;quot; : dirve strength is '3' and output buffer enabled.&amp;quot;</description>
              <bitWidth>29</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>D2D_MISC_PAD_CONF</name>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <description>D2D_MISC_PAD_CONF</description>
          <fields>
            <field>
              <name>MEM_D2D_SPARE</name>
              <description>[2:0] D2D SPARE PAD OEN/OEN2X control. When 0: Act as input buffer else output buffer with drive strength 2.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SOP_CONF_OVERRIDE</name>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <description>SOP_CONF_OVERRIDE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_DEBUGSS_STATUS</name>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <description>CC3XX_DEBUGSS_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_DEBUGMUX_SEL</name>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <description>CC3XX_DEBUGMUX_SEL</description>
          <fields>
            <field>
              <name>MEM_CC3XX_DEBUGMUX_SEL</name>
              <description>[15:0] debug mux select register. Upper 8 bits are used for debug module selection. Lower 8 bit [7:0] used inside debug module for selecting module specific signals. Bits[15:8: when set x&amp;quot;00&amp;quot; : GPRCM debug bus. When &amp;quot;o1&amp;quot; : SDIO debug debug bus when x&amp;quot;02&amp;quot; : autonoumous SPI when x&amp;quot;03&amp;quot; : TOPIC when x&amp;quot;04&amp;quot;: memss when x&amp;quot;25&amp;quot;: mcu debug bus : APPS debug when x&amp;quot;45&amp;quot;: mcu debug bus : NWP debug when x&amp;quot;65&amp;quot;: mcu debug bus : AHB2VBUS debug when x&amp;quot;85&amp;quot;: mcu debug bus : VBUS2HAB debug when x&amp;quot;95&amp;quot;: mcu debug bus : RCM debug when x&amp;quot;A5&amp;quot;: mcu debug bus : crypto debug when x&amp;quot;06&amp;quot;: WLAN debug bus when x&amp;quot;07&amp;quot;: debugss bus when x&amp;quot;08&amp;quot;: ADC debug when x&amp;quot;09&amp;quot;: SDIO PHY debug bus then &amp;quot;others&amp;quot; : no debug is selected</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALT_PC_VAL_NW</name>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <description>ALT_PC_VAL_NW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALT_PC_VAL_APPS</name>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <description>ALT_PC_VAL_APPS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_4</name>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <description>SPARE_REG_4</description>
          <fields>
            <field>
              <name>MEM_SPARE_REG_4</name>
              <description>[31:1] HW register</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_5</name>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <description>SPARE_REG_5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SH_SPI_CS_MASK</name>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <description>SH_SPI_CS_MASK</description>
          <fields>
            <field>
              <name>MEM_SH_SPI_CS_MASK</name>
              <description>[3:0] ( chip select 0 is unmasked after reset. When 1 : CS is unmasked or else masked. Valid configurations are 1000, 0100, 0010 or 0001. Any other setting can lead to unpredictable behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_DEVICE_TYPE</name>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <description>CC3XX_DEVICE_TYPE</description>
          <fields>
            <field>
              <name>DEVICE_TYPE</name>
              <description>[4:0] CC3XX Device type information.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_TOPMUXCTRL_IFORCE</name>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <description>MEM_TOPMUXCTRL_IFORCE</description>
          <fields>
            <field>
              <name>MEM_TOPMUXCTRL_IFORCE1</name>
              <description>[7:4] [4] 1: switch between WLAN_I2C_SCL and TOP_GPIO_PORT4_I2C closes 0: switch opens [5] 1: switch between WLAN_I2C_SCL and TOP_VSENSE_PORT closes 0: switch opens [6] 1: switch between WLAN_I2C_SCL and WLAN_ANA_TP4 closes 0: switch opens [7] Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_TOPMUXCTRL_IFORCE</name>
              <description>[3:0] [0] 1: switch between WLAN_I2C_SDA and TOP_GPIO_PORT3_I2C closes 0: switch opens [1] 1: switch between WLAN_I2C_SDA and TOP_IFORCE_PORT closes 0: switch opens [2] 1: switch between WLAN_I2C_SDA and WLAN_ANA_TP3 closes 0: switch opens [3] Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_DEV_PACKAGE_DETECT</name>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <description>CC3XX_DEV_PACKAGE_DETECT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AUTONMS_SPICLK_SEL</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>AUTONMS_SPICLK_SEL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC3XX_DEV_PADCONF</name>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <description>CC3XX_DEV_PADCONF</description>
          <fields>
            <field>
              <name>MEM_CC3XX_DEV_PADCONF</name>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_8</name>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <description>SPARE_REG_8</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_6</name>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <description>SPARE_REG_6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SPARE_REG_7</name>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <description>SPARE_REG_7</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_WLAN_ORBIT</name>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <description>APPS_WLAN_ORBIT</description>
          <fields>
            <field>
              <name>MEM_ORBIT_SPARE</name>
              <description>[31:10] Spare bit</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MEM_ORBIT_TEST_ID</name>
              <description>[7:2] Implies the test case ID that needs to run.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APPS_WLAN_SCRATCH_PAD</name>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <description>APPS_WLAN_SCRATCH_PAD</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <baseAddress>0x4402E800</baseAddress>
      <registers>
        <register>
          <name>CTRL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>ADC control register.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0_GAIN</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Channel 0 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1_GAIN</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Channel 1 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2_GAIN</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>Channel 2 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3_GAIN</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Channel 3 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH4_GAIN</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Channel 4 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH5_GAIN</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Channel 5 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH6_GAIN</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>Channel 6 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH7_GAIN</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Channel 7 gain setting</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0_IRQ_EN</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Channel 0 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1_IRQ_EN</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Channel 1 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2_IRQ_EN</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>Channel 2 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3_IRQ_EN</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Channel 3 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH4_IRQ_EN</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Channel 4 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH5_IRQ_EN</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Channel 5 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH6_IRQ_EN</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>Channel 6 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH7_IRQ_EN</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Channel 7 interrupt enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0_IRQ_STATUS</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Channel 0 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1_IRQ_STATUS</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Channel 1 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2_IRQ_STATUS</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>CH2_IRQ_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3_IRQ_STATUS</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Channel 3 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH4_IRQ_STATUS</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Channel 4 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH5_IRQ_STATUS</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>CH5_IRQ_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH6_IRQ_STATUS</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>Channel 6 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH7_IRQ_STATUS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Channel 7 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMA_MODE_EN</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>DMA mode enable register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TIMER_CONFIGURATION</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>ADC timer configuration register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TIMER_CURRENT_COUNT</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>ADC timer current count register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL0FIFODATA</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>CH0 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL1FIFODATA</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>CH1 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL2FIFODATA</name>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <description>CH2 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL3FIFODATA</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>CH3 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL4FIFODATA</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>CH4 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL5FIFODATA</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>CH5 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL6FIFODATA</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>CH6 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHANNEL7FIFODATA</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>CH7 FIFO DATA register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH0_FIFO_LVL</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>channel 0 FIFO Level register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH1_FIFO_LVL</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>Channel 1 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH2_FIFO_LVL</name>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <description>CH2_FIFO_LVL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH3_FIFO_LVL</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>Channel 3 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH4_FIFO_LVL</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>Channel 4 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH5_FIFO_LVL</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>CH5_FIFO_LVL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH6_FIFO_LVL</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>Channel 6 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH7_FIFO_LVL</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>Channel 7 interrupt status register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CH_ENABLE</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>CH_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HIB1P2</name>
      <baseAddress>0x4402F000</baseAddress>
      <registers>
        <register>
          <name>SRAM_SKA_LDO_PARAMETERS0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>SRAM_SKA_LDO_PARAMETERS0</description>
          <fields>
            <field>
              <name>MEM_SLDO_EN_SC_ITRIM_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>MEM_SLDO_EN_IQ_TRIM_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MEM_SLDO_VTRIM_LOWV</name>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>MEM_SLDO_SPARE_LOWV</name>
              <bitWidth>10</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NA1</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRAM_SKA_LDO_PARAMETERS1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>SRAM_SKA_LDO_PARAMETERS1</description>
          <fields>
            <field>
              <name>MEM_SKALDO_CTRL_LOWV</name>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MEM_SKALDO_VTRIM_LOWV</name>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>NA2</name>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_PARAMETERS0</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_PARAMETERS0</description>
          <fields>
            <field>
              <name>MEM_DCDC_DIG_VTRIM_LOWV_OVERRIDE</name>
              <description>[21:16] Override value for DCDC_DIG_VTRIM : Applicable only when bit [27] of DIG_DCDC_PARAMETERS1 [0x000C] is set to 1.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_PFM_RIPPLE_TRIM_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_IQ_CTRL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_NON_OV_CTRL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_SLP_DRV_DLY_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>NA3</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_PARAMETERS1</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_PARAMETERS1</description>
          <fields>
            <field>
              <name>NA4</name>
              <bitWidth>25</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_PARAMETERS2</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_PARAMETERS2</description>
          <fields>
            <field>
              <name>MEM_DCDC_DIG_PFET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_NFET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_PDRV_STAGGER_CTRL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_NDRV_STAGGER_CTRL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_PDRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_NDRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_TON_TRIM_LOWV</name>
              <bitWidth>8</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_PARAMETERS3</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_PARAMETERS3</description>
          <fields>
            <field>
              <name>MEM_DCDC_DIG_COT_CTRL_LOWV</name>
              <bitWidth>8</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_ILIM_TRIM_LOWV_OVERRIDE</name>
              <description>[20:13] Override value for DCDC_DIG_ILIM_TRIM : Applicable only when bit [25] of DIG_DCDC_PARAMETERS1 [0x000C] is set to 1</description>
              <bitWidth>8</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_ILIM_MASK_DLY_SEL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_NCOMP_TRIM_LOWV</name>
              <bitWidth>5</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_NCOMP_MASK_DLY_SEL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_PARAMETERS4</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_PARAMETERS4</description>
          <fields>
            <field>
              <name>NA7</name>
              <bitWidth>29</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_PARAMETERS5</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_PARAMETERS5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_PARAMETERS6</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_PARAMETERS6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_PARAMETERS0</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_PARAMETERS0</description>
          <fields>
            <field>
              <name>MEM_DCDC_ANA_VTRIM_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_PFM_RIPPLE_TRIM_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_IQ_CTRL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_NON_OV_CTRL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_SLP_DRV_DLY_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_PFET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_PARAMETERS1</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_PARAMETERS1</description>
          <fields>
            <field>
              <name>MEM_DCDC_ANA_NFET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_PDRV_STAGGER_CTRL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_NDRV_STAGGER_CTRL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_PDRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_NDRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_RAMP_HGT_LOWV</name>
              <bitWidth>5</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_HI_CLAMP_TRIM_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_LO_CLAMP_TRIM_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>NA8</name>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_PARAMETERS16</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_PARAMETERS16</description>
          <fields>
            <field>
              <name>MEM_DCDC_ANA_ILIM_TRIM_LOWV_OVERRIDE</name>
              <bitWidth>8</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_ILIM_MASK_DLY_SEL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_NCOMP_TRIM_LOWV</name>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_ANA_NCOMP_MASK_DLY_SEL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_PARAMETERS17</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_PARAMETERS17</description>
          <fields>
            <field>
              <name>NA17</name>
              <bitWidth>30</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_PARAMETERS18</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_PARAMETERS18</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_PARAMETERS19</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_PARAMETERS19</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS0</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS0</description>
          <fields>
            <field>
              <name>MEM_DCDC_FLASH_IQ_CTRL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_NON_OV_CTRL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_P1FET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N1FET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS1</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS1</description>
          <fields>
            <field>
              <name>MEM_DCDC_FLASH_P2FET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N2FET_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_P1DRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N1DRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_P2DRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N2DRV_STR_SEL_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_P1FET_NON_OV_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N1FET_NON_OV_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_P2FET_NON_OV_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N2FET_NON_OV_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS2</name>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS2</description>
          <fields>
            <field>
              <name>MEM_DCDC_FLASH_P1FET_STAGGER_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N1FET_STAGGER_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_P2FET_STAGGER_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_N2FET_STAGGER_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_NCOMP_TRIM_LOWV</name>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_NCOMP_MASK_DLY_TRIM_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_ILIM_TRIM_LOWV_OVERRIDE</name>
              <bitWidth>8</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_ILIM_MASK_DLY_SEL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS3</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS3</description>
          <fields>
            <field>
              <name>MEM_DCDC_FLASH_RAMP_HGT_LOWV</name>
              <bitWidth>5</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_VCLAMPH_TRIM_LOWV</name>
              <bitWidth>3</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_VCLAMPL_TRIM_LOWV</name>
              <bitWidth>3</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_VTRIM_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_PFM_RIPPLE_TRIM_LOWV</name>
              <bitWidth>4</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_FLASH_SLP_DRV_DLY_SEL_LOWV</name>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NA19</name>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS4</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS5</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS6</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS6</description>
          <fields>
            <field>
              <name>NA20</name>
              <bitWidth>30</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMBIST_PARAMETERS0</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>PMBIST_PARAMETERS0</description>
          <fields>
            <field>
              <name>MEM_PM_BIST_CTRL_LOWV</name>
              <bitWidth>20</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>NA21</name>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMBIST_PARAMETERS1</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>PMBIST_PARAMETERS1</description>
          <fields>
            <field>
              <name>MEM_PM_BIST_SPARE_LOWV</name>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>NA22</name>
              <bitWidth>15</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMBIST_PARAMETERS2</name>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <description>PMBIST_PARAMETERS2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMBIST_PARAMETERS3</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>PMBIST_PARAMETERS3</description>
          <fields>
            <field>
              <name>MEM_PMTEST_SPARE_LOWV</name>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_PMTEST_LOAD_TRIM_LOWV</name>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NA23</name>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS8</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS8</description>
          <fields>
            <field>
              <name>MEM_FLASH_HIGH_SUP_TRIM_LOWV</name>
              <bitWidth>5</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>MEM_FLASH_LOW_SUP_TRIM_LOWV</name>
              <bitWidth>5</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>NA24</name>
              <bitWidth>21</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_PARAMETERS_OVERRIDE</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_PARAMETERS_OVERRIDE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FLASH_DCDC_PARAMETERS_OVERRIDE</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>FLASH_DCDC_PARAMETERS_OVERRIDE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_VTRIM_CFG</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_VTRIM_CFG</description>
          <fields>
            <field>
              <name>MEM_DCDC_DIG_RUN_VTRIM</name>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_DSLP_VTRIM</name>
              <bitWidth>6</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_LPDS_VTRIM</name>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SPARE_RW</name>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIG_DCDC_FSM_PARAMETERS</name>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <description>DIG_DCDC_FSM_PARAMETERS</description>
          <fields>
            <field>
              <name>MEM_DCDC_DIG_DSLP_ENTER_COT_TO_VTRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_DSLP_ENTER_VTRIM_TO_SLEEP</name>
              <bitWidth>3</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_DSLP_EXIT_SLEEP_TO_VTRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_DSLP_EXIT_VTRIM_TO_COT</name>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MEM_DCDC_DIG_DSLP_EXIT_COT_TO_RUN</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ANA_DCDC_FSM_PARAMETERS</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>ANA_DCDC_FSM_PARAMETERS</description>
          <fields>
            <field>
              <name>MEM_DCDC_ANA_DSLP_EXIT_SLEEP_TO_RUN</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRAM_SKA_LDO_FSM_PARAMETERS</name>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <description>SRAM_SKA_LDO_FSM_PARAMETERS</description>
          <fields>
            <field>
              <name>MEM_SKA_LDO_EN_TO_SRAM_LDO_DIS</name>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MEM_SRAM_LDO_EN_TO_SKA_LDO_DIS</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BGAP_DUTY_CYCLING_EXIT_CFG</name>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <description>BGAP_DUTY_CYCLING_EXIT_CFG</description>
          <fields>
            <field>
              <name>MEM_BGAP_DUTY_CYCLING_EXIT_TIME</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CM_OSC_16M_CONFIG</name>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <description>CM_OSC_16M_CONFIG</description>
          <fields>
            <field>
              <name>MEM_CM_OSC_16M_TRIM</name>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MEM_CM_OSC_16M_SPARE</name>
              <bitWidth>6</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_CM_SLI_16M_TRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SOP_SENSE_VALUE</name>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <description>SOP_SENSE_VALUE</description>
          <fields>
            <field>
              <name>SOP_SENSE_VALUE</name>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_RTC_TIMER_LSW_1P2</name>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <description>HIB_RTC_TIMER_LSW_1P2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_RTC_TIMER_MSW_1P2</name>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <description>HIB_RTC_TIMER_MSW_1P2</description>
          <fields>
            <field>
              <name>HIB_RTC_TIMER_MSW</name>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BGAP_TRIM_OVERRIDES</name>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <description>BGAP_TRIM_OVERRIDES</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG0</name>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EFUSE_READ_REG1</name>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <description>EFUSE_READ_REG1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>POR_TEST_CTRL</name>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <description>POR_TEST_CTRL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_SYNC_CALIB_CFG0</name>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_SYNC_CALIB_CFG0</description>
          <fields>
            <field>
              <name>MEM_CFG_CALIB_TIME</name>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_SYNC_CALIB_CFG1</name>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_SYNC_CALIB_CFG1</description>
          <fields>
            <field>
              <name>FAST_CALIB_COUNT</name>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_SYNC_CFG2</name>
          <addressOffset>0xEC</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_SYNC_CFG2</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_SYNC_TSF_ADJ_VAL</name>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_SYNC_TSF_ADJ_VAL</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_RTC_GTS_TIMESTAMP_LSW</name>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_RTC_GTS_TIMESTAMP_LSW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_RTC_GTS_TIMESTAMP_MSW</name>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_RTC_GTS_TIMESTAMP_MSW</description>
          <fields>
            <field>
              <name>RTC_GTS_TIMESTAMP_MSW</name>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_RTC_WUP_TIMESTAMP_LSW</name>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_RTC_WUP_TIMESTAMP_LSW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_RTC_WUP_TIMESTAMP_MSW</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_RTC_WUP_TIMESTAMP_MSW</description>
          <fields>
            <field>
              <name>RTC_WUP_TIMESTAMP_MSW</name>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_SYNC_WAKE_OFFSET_ERR</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_SYNC_WAKE_OFFSET_ERR</description>
          <fields>
            <field>
              <name>WUP_OFFSET_ERROR</name>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_SYNC_TSF_CURR_VAL_LSW</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_SYNC_TSF_CURR_VAL_LSW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TIMER_SYNC_TSF_CURR_VAL_MSW</name>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <description>HIB_TIMER_SYNC_TSF_CURR_VAL_MSW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CM_SPARE</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>CM_SPARE</description>
          <fields>
            <field>
              <name>CM_SPARE_OUT</name>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MEM_CM_TEST_CTRL</name>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_CM_SPARE</name>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PORPOL_SPARE</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>PORPOL_SPARE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_DIG_DCDC_CLK_CONFIG</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>MEM_DIG_DCDC_CLK_CONFIG</description>
          <fields>
            <field>
              <name>MEM_DIG_DCDC_CLK_PLLGEN_OFF_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_DIG_DCDC_CLK_PLLGEN_ON_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_ANA_DCDC_CLK_CONFIG</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>MEM_ANA_DCDC_CLK_CONFIG</description>
          <fields>
            <field>
              <name>MEM_ANA_DCDC_CLK_PLLGEN_OFF_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_ANA_DCDC_CLK_PLLGEN_ON_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_FLASH_DCDC_CLK_CONFIG</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>MEM_FLASH_DCDC_CLK_CONFIG</description>
          <fields>
            <field>
              <name>MEM_FLASH_DCDC_CLK_PLLGEN_OFF_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_FLASH_DCDC_CLK_PLLGEN_ON_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_PA_DCDC_CLK_CONFIG</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>MEM_PA_DCDC_CLK_CONFIG</description>
          <fields>
            <field>
              <name>MEM_PA_DCDC_CLK_PLLGEN_OFF_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_PA_DCDC_CLK_PLLGEN_ON_TIME</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_SLDO_VNWA_OVERRIDE</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>MEM_SLDO_VNWA_OVERRIDE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_BGAP_DUTY_CYCLING_ENABLE_OVERRIDE</name>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <description>MEM_BGAP_DUTY_CYCLING_ENABLE_OVERRIDE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_FSM_DEBUG</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>MEM_HIB_FSM_DEBUG</description>
          <fields>
            <field>
              <name>SRAM_PS</name>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ANA_DCDC_PS</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIG_DCDC_PS</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_SLDO_VNWA_SW_CTRL</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>MEM_SLDO_VNWA_SW_CTRL</description>
          <fields>
            <field>
              <name>MEM_SLDO_VNWA_SW_CTRL</name>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_SLDO_WEAK_PROCESS</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>MEM_SLDO_WEAK_PROCESS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_PA_DCDC_OV_UV_STATUS</name>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <description>MEM_PA_DCDC_OV_UV_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_CM_TEST_MODE</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>MEM_CM_TEST_MODE</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HIB3P3</name>
      <baseAddress>0x4402F800</baseAddress>
      <registers>
        <register>
          <name>MEM_HIB_REQ</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>MEM_HIB_REQ</description>
          <fields>
            <field>
              <name>NU1</name>
              <bitWidth>7</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_TIMER_ENABLE</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_TIMER_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_TIMER_RESET</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_TIMER_RESET</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_TIMER_READ</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_TIMER_READ</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_TIMER_LSW</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_TIMER_LSW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_TIMER_MSW</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_TIMER_MSW</description>
          <fields>
            <field>
              <name>HIB_RTC_TIMER_MSW</name>
              <description>[15:0] Upper 32b value of the latched RTC-Timer.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_WAKE_EN</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_WAKE_EN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_WAKE_LSW_CONF</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_WAKE_LSW_CONF</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_WAKE_MSW_CONF</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_WAKE_MSW_CONF</description>
          <fields>
            <field>
              <name>MEM_HIB_RTC_WAKE_MSW_CONF</name>
              <description>[15:0] Configuration for RTC-Timer Wakeup (Upper 16b word)</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_INT_OSC_CONF</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>MEM_INT_OSC_CONF</description>
          <fields>
            <field>
              <name>MEM_CM_INTOSC_32K_SPARE</name>
              <bitWidth>6</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>MEM_CM_INTOSC_32K_TRIM</name>
              <bitWidth>6</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_XTAL_OSC_CONF</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>MEM_XTAL_OSC_CONF</description>
          <fields>
            <field>
              <name>MEM_CM_XTAL_TRIM</name>
              <bitWidth>6</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MEM_CM_SLI_32K_TRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>MEM_CM_FREF_32K_SLICER_ITRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_CM_EN_INPUT_SENSE</name>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_BGAP_PARAMETERS0</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>MEM_BGAP_PARAMETERS0</description>
          <fields>
            <field>
              <name>MEM_VBOK4BG_COMP_TRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>MEM_BGAP_SPARE</name>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_BGAP_PARAMETERS1</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>MEM_BGAP_PARAMETERS1</description>
          <fields>
            <field>
              <name>MEM_BGAP_ACT_IREF_ITRIM</name>
              <bitWidth>5</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_DETECTION_STATUS</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>MEM_HIB_DETECTION_STATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_MISC_CONTROLS</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>MEM_HIB_MISC_CONTROLS</description>
          <fields>
            <field>
              <name>MEM_HIB_POK_POR_COMP_TRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_CONFIG</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>MEM_HIB_CONFIG</description>
          <fields>
            <field>
              <name>TOP_MUX_CTRL_SOP_SPIO</name>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_IRQ_ENABLE</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_IRQ_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_IRQ_LSW_CONF</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_IRQ_LSW_CONF</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_RTC_IRQ_MSW_CONF</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>MEM_HIB_RTC_IRQ_MSW_CONF</description>
          <fields>
            <field>
              <name>HIB_RTC_IRQ_MSW_CONF</name>
              <description>[15:0] Configuration for MSW of thr RTC-Timestamp at which the interrupt need to be generated</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_UART_CONF</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>MEM_HIB_UART_CONF</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_GPIO_WAKE_EN</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>MEM_GPIO_WAKE_EN</description>
          <fields>
            <field>
              <name>MEM_GPIO_WAKE_EN</name>
              <description>[7:0] 1 - Enable the GPIO-Autonomous mode wakeup during Hibernate mode ; This is an auto-clear bit, once programmed to 1, it will latched into an internal register which remain asserted until the Hib-wakeup is initiated.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_GPIO_WAKE_CONF</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>MEM_GPIO_WAKE_CONF</description>
          <fields>
            <field>
              <name>MEM_GPIO_WAKE_CONF</name>
              <description>[15:0] Configuration to say whether the GPIO wakeup has to happen on Level0 or falling-edge for the given group. 00?  Level0 01?  Level1 10?- Fall-edge 11?- Rise-edge [1:0]  Conf for GPIO0 [3:2]  Conf for GPIO1 [5:4]  Conf for GPIO2 [7:6]  Conf for GPIO3 [9:8]  Conf for GPIO4 [11:10]  Conf for GPIO5 [13:12]  Conf for GPIO6</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_PAD_OEN_RET33_CONF</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>MEM_PAD_OEN_RET33_CONF</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_UART_RTS_OEN_RET33_CONF</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>MEM_UART_RTS_OEN_RET33_CONF</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_JTAG_CONF</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>MEM_JTAG_CONF</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_REG0</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>MEM_HIB_REG0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_REG1</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>MEM_HIB_REG1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_REG2</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>MEM_HIB_REG2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_REG3</name>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <description>MEM_HIB_REG3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_SEQUENCER_CFG0</name>
          <addressOffset>0x45C</addressOffset>
          <size>32</size>
          <description>MEM_HIB_SEQUENCER_CFG0</description>
          <fields>
            <field>
              <name>MEM_BDC_EV0_TO_EV1_TIME</name>
              <description>[31:16] Configuration for the number of slow-clks between de-assertion of EN_BG_3P3V to assertion of EN_BG_3P3V</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_EV3_TO_EV4_TIME</name>
              <description>[14:13] Configuration for the number of slow-clks between assertion of EN_COMP_3P3V and assertion of EN_COMP_LATCH_3P3V</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_EV2_TO_EV3_TIME</name>
              <description>[12:11] Configuration for the number of slow-clks between assertion of (EN_CAP_SW_3P3V,EN_COMP_REF) and assertion of (EN_COMP_3P3V)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_EV1_TO_EV2_TIME</name>
              <description>[10:9] Configuration for the number of slow-clks between assertion of (EN_BG_3P3V) and assertion of (EN_CAP_SW_3P3V, EN_COMP_REF_3P3V)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_SEQUENCER_CFG1</name>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <description>MEM_HIB_SEQUENCER_CFG1</description>
          <fields>
            <field>
              <name>MEM_BDC_EV5_TO_EV6_TIME</name>
              <description>[15:14] Configuration for number of slow-clks between de-assertion of EN_COMP_LATCH and assertion of</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_TO_ACTIVE_EV1_TO_EV2_TIME</name>
              <description>[13:12] Configuration for number of slow-clks between assertion of EN_COMP_REF to assertion of EN_COMP during HIB-Exit</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_TO_ACTIVE_EV0_TO_EV1_TIME</name>
              <description>[11:10] TBD</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_TO_ACTIVE_EV0_TO_ACTIVE</name>
              <description>[9:8] Configuration in number of slow-clks between assertion of (EN_BGAP_3P3V, EN_CAP_SW_3P3V, EN_ACT_IREF_3P3V, EN_COMP_REF) to assertion of EN_COMP_3P3V</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MEM_ACTIVE_TO_BDC_EV1_TO_BDC_EV0_TIME</name>
              <description>[7:6] Configuration in number of slow-clks between de-assertion of (EN_COMP_3P3V, EN_COMP_REF_3P3V, EN_ACT_IREF_3P3V, EN_CAP_SW_3P3V) to deassertion of EN_BGAP_3P3V.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>NU1</name>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_MISC_CONFIG</name>
          <addressOffset>0x464</addressOffset>
          <size>32</size>
          <description>MEM_HIB_MISC_CONFIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_WAKE_STATUS</name>
          <addressOffset>0x468</addressOffset>
          <size>32</size>
          <description>MEM_HIB_WAKE_STATUS</description>
          <fields>
            <field>
              <name>HIB_WAKE_SRC</name>
              <description>[4:1] &amp;quot;0100&amp;quot; - GPIO ; &amp;quot;0010&amp;quot; - RTC ; &amp;quot;0001&amp;quot; - UART Others - Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_LPDS_GPIO_SEL</name>
          <addressOffset>0x46C</addressOffset>
          <size>32</size>
          <description>MEM_HIB_LPDS_GPIO_SEL</description>
          <fields>
            <field>
              <name>HIB_LPDS_GPIO_SEL</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MEM_HIB_SEQUENCER_CFG2</name>
          <addressOffset>0x470</addressOffset>
          <size>32</size>
          <description>MEM_HIB_SEQUENCER_CFG2</description>
          <fields>
            <field>
              <name>MEM_ACTIVE_TO_BDC_EV0_TO_ACTIVE_TO_BDC_EV1_TIME</name>
              <description>[10:9] Deassertion of EN_COMP_LATCH_3P3 to deassertion of (EN_COMP_3P3, EN_COMP_REF_3P3, EN_ACT_IREF_3P3, EN_CAP_SW_3P3)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_EV4_TO_EV5_TIME</name>
              <description>[8:6] Assertion of EN_COMP_LATCH_3P3 to deassertion of EN_COMP_LATCH_3P3</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_EV6_TO_EV7_TIME</name>
              <description>[5:4] Deassertion of (EN_CAP_SW_3P3, EN_COMP_REF_3P3, EN_COMP_3P3, EN_COMP_OUT_LATCH_3P3) to deassertion of EN_BGAP_3P3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_BDC_TO_ACTIVE_EV1_TO_EV2_TIME</name>
              <description>[3:2] Assertion of EN_COMP_3P3 to assertion of EN_COMPOUT_LATCH_3P3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MEM_HIB_TO_ACTIVE_EV2_TO_EV3_TIME</name>
              <description>[1:0] Assertion of EN_COMP_3P3 to assertion of EN_COMPOUT_LATCH_3P3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIBANA_SPARE_LOWV</name>
          <addressOffset>0x474</addressOffset>
          <size>32</size>
          <description>HIBANA_SPARE_LOWV</description>
          <fields>
            <field>
              <name>MEM_HIBANA_SPARE1</name>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MEM_HIBANA_SPARE0</name>
              <bitWidth>17</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_TMUX_CTRL</name>
          <addressOffset>0x478</addressOffset>
          <size>32</size>
          <description>HIB_TMUX_CTRL</description>
          <fields>
            <field>
              <name>MEM_HD_TMUX_CNTRL</name>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_1P2_1P8_LDO_TRIM</name>
          <addressOffset>0x47C</addressOffset>
          <size>32</size>
          <description>HIB_1P2_1P8_LDO_TRIM</description>
          <fields>
            <field>
              <name>MEM_HD_1P2_LDO_VTRIM</name>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MEM_HD_1P8_LDO_VTRIM</name>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_COMP_TRIM</name>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <description>HIB_COMP_TRIM</description>
          <fields>
            <field>
              <name>MEM_HD_COMP_TRIM</name>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_EN_TS</name>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <description>HIB_EN_TS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_1P8V_DET_EN</name>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <description>HIB_1P8V_DET_EN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_VBAT_MON_EN</name>
          <addressOffset>0x48C</addressOffset>
          <size>32</size>
          <description>HIB_VBAT_MON_EN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_NHIB_ENABLE</name>
          <addressOffset>0x490</addressOffset>
          <size>32</size>
          <description>HIB_NHIB_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HIB_UART_RTS_SW_ENABLE</name>
          <addressOffset>0x494</addressOffset>
          <size>32</size>
          <description>HIB_UART_RTS_SW_ENABLE</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DTHE</name>
      <baseAddress>0x44030000</baseAddress>
      <registers>
        <register>
          <name>SHA_IM</name>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <description>SHA_IM</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SHA_RIS</name>
          <addressOffset>0x814</addressOffset>
          <size>32</size>
          <description>SHA_RIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SHA_MIS</name>
          <addressOffset>0x818</addressOffset>
          <size>32</size>
          <description>SHA_MIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SHA_IC</name>
          <addressOffset>0x81C</addressOffset>
          <size>32</size>
          <description>SHA_IC</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_IM</name>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <description>AES_IM</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_RIS</name>
          <addressOffset>0x824</addressOffset>
          <size>32</size>
          <description>AES_RIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_MIS</name>
          <addressOffset>0x828</addressOffset>
          <size>32</size>
          <description>AES_MIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_IC</name>
          <addressOffset>0x82C</addressOffset>
          <size>32</size>
          <description>AES_IC</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DES_IM</name>
          <addressOffset>0x830</addressOffset>
          <size>32</size>
          <description>DES_IM</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DES_RIS</name>
          <addressOffset>0x834</addressOffset>
          <size>32</size>
          <description>DES_RIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DES_MIS</name>
          <addressOffset>0x838</addressOffset>
          <size>32</size>
          <description>DES_MIS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DES_IC</name>
          <addressOffset>0x83C</addressOffset>
          <size>32</size>
          <description>DES_IC</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EIP_CGCFG</name>
          <addressOffset>0xA00</addressOffset>
          <size>32</size>
          <description>EIP_CGCFG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EIP_CGREQ</name>
          <addressOffset>0xA04</addressOffset>
          <size>32</size>
          <description>EIP_CGREQ</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CRC_CTRL</name>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <description>CRC_CTRL</description>
          <fields>
            <field>
              <name>INIT</name>
              <description>[14:13] Initialize the CRC 00  use SEED register context as starting value 10  all zero? 11  all one? This is self clearing. With first write to data register this value clears to zero and remain zero for rest of the operation unless written again</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>[5:4] Endian control [0]  swap byte in half-word [1]  swap half word</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TYPE</name>
              <description>[3:0] Type of operation 0000  polynomial 0x8005 0001  polynomial 0x1021 0010  polynomial 0x4C11DB7 0011  polynomial 0x1EDC6F41 1000  TCP checksum TYPE in DTHE_S_CRC_CTRL &amp; DTHE_S_CRC_CTRL should be exclusive</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CRC_SEED</name>
          <addressOffset>0xC10</addressOffset>
          <size>32</size>
          <description>CRC_SEED</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CRC_DIN</name>
          <addressOffset>0xC14</addressOffset>
          <size>32</size>
          <description>CRC_DIN</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CRC_RSLT_PP</name>
          <addressOffset>0xC18</addressOffset>
          <size>32</size>
          <description>CRC_RSLT_PP</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RAND_KEY0</name>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <description>RAND_KEY0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RAND_KEY1</name>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <description>RAND_KEY1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RAND_KEY2</name>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <description>RAND_KEY2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RAND_KEY3</name>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <description>RAND_KEY3</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SHAMD5</name>
      <baseAddress>0x44035000</baseAddress>
      <registers>
        <register>
          <name>ODIGEST_A</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [127:96] for MD5 [159:128] for SHA-1 [255:224] for SHA-2 / HMAC Key [31:0] for HMAC key proc READ: Outer Digest [127:96] for MD5 [159:128] for SHA-1 [255:224] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODIGEST_B</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [95:64] for MD5 [127:96] for SHA-1 [223:192] for SHA-2 / HMAC Key [63:32] for HMAC key proc READ: Outer Digest [95:64] for MD5 [127:96] for SHA-1 [223:192] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODIGEST_C</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [63:32] for MD5 [95:64] for SHA-1 [191:160] for SHA-2 / HMAC Key [95:64] for HMAC key proc READ: Outer Digest [63:32] for MD5 [95:64] for SHA-1 [191:160] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODIGEST_D</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [31:0] for MD5 [63:31] for SHA-1 [159:128] for SHA-2 / HMAC Key [127:96] for HMAC key proc READ: Outer Digest [31:0] for MD5 [63:32] for SHA-1 [159:128] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODIGEST_E</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [31:0] for SHA-1 [127:96] for SHA-2 / HMAC Key [159:128] for HMAC key proc READ: Outer Digest [31:0] for SHA-1 [127:96] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODIGEST_F</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [95:64] for SHA-2 / HMAC Key [191:160] for HMAC key proc READ: Outer Digest [95:64] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODIGEST_G</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [63:32] for SHA-2 / HMAC Key [223:192] for HMAC key proc READ: Outer Digest [63:32] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ODIGEST_H</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>WRITE: Outer Digest [31:0] for SHA-2 / HMAC Key [255:224] for HMAC key proc READ: Outer Digest [31:0] for SHA-2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_A</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [127:96] for MD5 [159:128] for SHA-1 [255:224] for SHA-2 / HMAC Key [287:256] for HMAC key proc READ: Intermediate / Inner Digest [127:96] for MD5 [159:128] for SHA-1 [255:224] for SHA-2 / Result Digest/MAC [127:96] for MD5 [159:128] for SHA-1 [223:192] for SHA-2 224 [255:224] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_B</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [95:64] for MD5 [127:96] for SHA-1 [223:192] for SHA-2 / HMAC Key [319:288] for HMAC key proc READ: Intermediate / Inner Digest [95:64] for MD5 [127:96] for SHA-1 [223:192] for SHA-2 / Result Digest/MAC [95:64] for MD5 [127:96] for SHA-1 [191:160] for SHA-2 224 [223:192] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_C</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [63:32] for MD5 [95:64] for SHA-1 [191:160] for SHA- 2 / HMAC Key [351:320] for HMAC key proc READ: Intermediate / Inner Digest [63:32] for MD5 [95:64] for SHA-1 [191:160] for SHA-2 / Result Digest/MAC [63:32] for MD5 [95:64] for SHA-1 [159:128] for SHA-2 224 [191:160] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_D</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [31:0] for MD5 [63:32] for SHA-1 [159:128] for SHA-2 / HMAC Key [383:352] for HMAC key proc READ: Intermediate / Inner Digest [31:0] for MD5 [63:32] for SHA-1 [159:128] for SHA-2 / Result Digest/MAC [31:0] for MD5 [63:32] for SHA-1 [127:96] for SHA-2 224 [159:128] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_E</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [31:0] for SHA-1 [127:96] for SHA-2 / HMAC Key [415:384] for HMAC key proc READ: Intermediate / Inner Digest [31:0] for SHA-1 [127:96] for SHA-2 / Result Digest/MAC [31:0] for SHA-1 [95:64] for SHA-2 224 [127:96] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_F</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [95:64] for SHA-2 / HMAC Key [447:416] for HMAC key proc READ: Intermediate / Inner Digest [95:64] for SHA-2 / Result Digest/MAC [63:32] for SHA-2 224 [95:64] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_G</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [63:32] for SHA-2 / HMAC Key [479:448] for HMAC key proc READ: Intermediate / Inner Digest [63:32] for SHA-2 / Result Digest/MAC [31:0] for SHA-2 224 [63:32] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IDIGEST_H</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>WRITE: Inner / Initial Digest [31:0] for SHA-2 / HMAC Key [511:480] for HMAC key proc READ: Intermediate / Inner Digest [31:0] for SHA-2 / Result Digest/MAC [31:0] for SHA-2 256</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIGEST_COUNT</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>WRITE: Initial Digest Count ([31:6] only [5:0] assumed 0) READ: Result / IntermediateDigest Count The initial digest byte count for hash/HMAC continue operations (HMAC Key Processing = 0 and Use Algorithm Constants = 0) on the Secure World must be written to this register prior to starting the operation by writing to S_HASH_MODE. When either HMAC Key Processing is 1 or Use Algorithm Constants is 1 this register does not need to be written it will be overwritten with 64 (1 hash block of key XOR ipad) or 0 respectively automatically. When starting a HMAC operation from pre-computes (HMAC Key Processing is 0) then the value 64 must be written here to compensate for the appended key XOR ipad block. Note that the value written should always be a 64 byte multiple the lower 6 bits written are ignored. The updated digest byte count (initial digest byte count + bytes processed) can be read from this register when the status register indicates that the operation is done or suspended due to a context switch request or when a Secure World context out DMA is requested. In Advanced DMA mode when not suspended with a partial result reading the SHAMD5_DIGEST_COUNT register triggers the Hash/HMAC Engine to start the next context input DMA. Therefore reading the SHAMD5_DIGEST_COUNT register should always be the last context-read action if not suspended with a partial result (i.e. PartHashReady interrupt not pending).</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MODE</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Register SHAMD5_MODE</description>
          <fields>
            <field>
              <name>ALGO</name>
              <description>[2:1] These bits select the hash algorithm to be used for processing: 0x0 md5_128 algorithm 0x1 sha1_160 algorithm 0x2 sha2_224 algorithm 0x3 sha2_256 algorithm</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LENGTH</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>WRITE: Block Length / Remaining Byte Count (bytes) READ: Remaining Byte Count. The value programmed MUST be a 64-byte multiple if Close Hash is set to 0. This register is also the trigger to start processing: once this register is written the core will commence requesting input data via DMA or IRQ (if programmed length > 0) and start processing. The remaining byte count for the active operation can be read from this register when the interrupt status register indicates that the operation is suspended due to a context switch request.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA0_IN</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>Data input message 0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA1_IN</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>Data input message 1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA2_IN</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>Data input message 2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA3_IN</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>Data input message 3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA4_IN</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>Data input message 4</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA5_IN</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>Data input message 5</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA6_IN</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>Data input message 6</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA7_IN</name>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <description>Data input message 7</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA8_IN</name>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <description>Data input message 8</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA9_IN</name>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <description>Data input message 9</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA10_IN</name>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <description>Data input message 10</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA11_IN</name>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <description>Data input message 11</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA12_IN</name>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <description>Data input message 12</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA13_IN</name>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <description>Data input message 13</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA14_IN</name>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <description>Data input message 14</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA15_IN</name>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <description>Data input message 15</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REVISION</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Register SHAMD5_REV</description>
          <fields>
            <field>
              <name>SCHEME</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>FUNC</name>
              <description>[27:16] Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>R_RTL</name>
              <description>[15:11] RTL Version (R) maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>X_MAJOR</name>
              <description>[10:8] Major Revision (X) maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUSTOM</name>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Y_MINOR</name>
              <description>[5:0] Minor Revision (Y) maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R S X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCONFIG</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>Register SHAMD5_SYSCONFIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSSTATUS</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>Register SHAMD5_SYSSTATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQSTATUS</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>Register SHAMD5_IRQSTATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQENABLE</name>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <description>Register SHAMD5_IRQENABLE. The SHAMD5_IRQENABLE register contains an enable bit for each unique interrupt for the public side. An interrupt is enabled when both the global enable in SHAMD5_SYSCONFIG (PIT_en) and the bit in this register are both set to 1. An interrupt that is enabled is propagated to the SINTREQUEST_P output. Please note that the dedicated partial hash output (SINTREQUEST_PART_P) is not affected by this register it is only affected by the global enable SHAMD5_SYSCONFIG (PIT_en).</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_A</name>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_A</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_B</name>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_B</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_C</name>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_C</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_D</name>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_D</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_E</name>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_E</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_F</name>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_F</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_G</name>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_G</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_H</name>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_H</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_I</name>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_I</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_J</name>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_J</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_K</name>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_K</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_L</name>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_L</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_M</name>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_M</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_N</name>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_N</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_O</name>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_O</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_ODIGEST_P</name>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <description>HASH512_ODIGEST_P</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_A</name>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_A</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_B</name>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_B</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_C</name>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_C</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_D</name>
          <addressOffset>0x24C</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_D</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_E</name>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_E</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_F</name>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_F</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_G</name>
          <addressOffset>0x258</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_G</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_H</name>
          <addressOffset>0x25C</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_H</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_I</name>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_I</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_J</name>
          <addressOffset>0x264</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_J</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_K</name>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_K</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_L</name>
          <addressOffset>0x26C</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_L</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_M</name>
          <addressOffset>0x270</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_M</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_N</name>
          <addressOffset>0x274</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_N</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_O</name>
          <addressOffset>0x278</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_O</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_IDIGEST_P</name>
          <addressOffset>0x27C</addressOffset>
          <size>32</size>
          <description>HASH512_IDIGEST_P</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_DIGEST_COUNT</name>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <description>HASH512_DIGEST_COUNT</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_MODE</name>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <description>HASH512_MODE</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH512_LENGTH</name>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <description>HASH512_LENGTH</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES</name>
      <baseAddress>0x44037000</baseAddress>
      <registers>
        <register>
          <name>KEY2_6</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>XTS second key / CBC-MAC third key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_7</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>XTS second key (MSW for 256-bit key) / CBC-MAC third key (MSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_4</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>XTS / CCM second key / CBC-MAC third key (LSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_5</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>XTS second key (MSW for 192-bit key) / CBC-MAC third key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_2</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>XTS / CCM / CBC-MAC second key / Hash Key input</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_3</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>XTS second key (MSW for 128-bit key) + CCM/CBC-MAC second key (MSW) / Hash Key input (MSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_0</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>XTS / CCM / CBC-MAC second key (LSW) / Hash Key input (LSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_1</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>XTS / CCM / CBC-MAC second key / Hash Key input</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_6</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Key (LSW for 256-bit key)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_7</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Key (MSW for 256-bit key)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_4</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Key (LSW for 192-bit key)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_5</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>Key (MSW for 192-bit key)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_2</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_3</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Key (MSW for 128-bit key)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_0</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Key (LSW for 128-bit key)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_1</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>Key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IV_IN_0</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Initialization Vector input (LSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IV_IN_1</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Initialization vector input</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IV_IN_2</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Initialization vector input</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IV_IN_3</name>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <description>Initialization Vector input (MSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>register determines the mode of operation of the AES Engine</description>
          <fields>
            <field>
              <name>CCM</name>
              <description>[24:22] Defines M? that indicated the length of the authentication field for CCM operations; the authentication field length equals two times (the value of CCM-M plus one). Note that the AES Engine always returns a 128-bit authentication field@@ of which the M least significant bytes are valid. All values are supported.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>CCM_L</name>
              <description>[21:19] Defines L? that indicated the width of the length field for CCM operations; the length field in bytes equals the value of CMM-L plus one. Supported values for L are (programmed value): 2 (1)@@ 4 (3) and 8 (7).</description>
              <bitWidth>3</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>GCM</name>
              <description>[17:16] AES-GCM mode is selected.this is a combined mode@@ using the Galois field multiplier GF(2^128) for authentication and AES-CTR mode for encryption@@ the bits specify the GCM mode. 0x0 No operation 0x1 GHASH with H loaded and Y0-encrypted forced to zero 0x2 GHASH with H loaded and Y0-encrypted calculated internally 0x3 Autonomous GHASH (both H and Y0-encrypted calculated internally)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>XTS</name>
              <description>[12:11] AES-XTS operation is selected; the bits specify the XTS mode.01 = Previous/intermediate tweak value and j loaded (value is loaded via IV@@ j is loaded via the AAD length register) 0x0 No operation 0x1 Previous/intermediate tweak value and j loaded (value is loaded via IV@@ j is loaded via the AAD length register) 0x2 Key2@@ i and j loaded (i is loaded via IV@@ j is loaded via the AAD length register) 0x3 Key2 and i loaded@@ j=0 (i is loaded via IV)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CTR_WIDTH</name>
              <description>[8:7] Specifies the counter width for AES-CTR mode 0x0 Counter is 32 bits 0x1 Counter is 64 bits 0x2 Counter is 128 bits 0x3 Counter is 192 bits</description>
              <bitWidth>2</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>KEY_SIZE</name>
              <description>[4:3] key size 0x0 reserved 0x1 Key is 128 bits. 0x2 Key is 192 bits 0x3 Key is 256</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>C_LENGTH_0</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Crypto data length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61  1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32  2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>C_LENGTH_1</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Crypto data length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61  1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32  2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes.</description>
          <fields>
            <field>
              <name>LENGTH</name>
              <description>[28:0] Data length (MSW) length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61  1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32  2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AUTH_LENGTH</name>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <description>AAD data length. The authentication length register store the authentication data length in bytes for combined modes only (GCM or CCM) Supported AAD-lengths for CCM are from 0 to (2^16 - 2^8) bytes. For GCM any value up to (2^32 - 1) bytes can be used. Once processing with this context is started@@ this length decrements to zero. A write to this register triggers the engine to start using this context for GCM and CCM. For XTS this register is optionally used to load j. Loading of j is only required if j != 0. j is a 28-bit value and must be written to bits [31-4] of this register. j represents the sequential number of the 128-bit block inside the data unit. For the first block in a unit@@ this value is zero. It is not required to provide a j for each new data block within a unit. Note that it is possible to start with a j unequal to zero; refer to Table 4 for more details. For a Host read operation@@ these registers return all-zeroes.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA_IN_0</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Data register to read and write plaintext/ciphertext (MSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA_IN_1</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Data register to read and write plaintext/ciphertext</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA_IN_2</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Data register to read and write plaintext/ciphertext</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA_IN_3</name>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <description>Data register to read and write plaintext/ciphertext (LSW)</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAG_OUT_0</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>TAG_OUT_0</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAG_OUT_1</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>TAG_OUT_1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAG_OUT_2</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>TAG_OUT_2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAG_OUT_3</name>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <description>TAG_OUT_3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REVISION</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>Register AES_REVISION</description>
          <fields>
            <field>
              <name>SCHEME</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>FUNC</name>
              <description>[27:16] Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>R_RTL</name>
              <description>[15:11] RTL Version (R)@@ maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>X_MAJOR</name>
              <description>[10:8] Major Revision (X)@@ maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUSTOM</name>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Y_MINOR</name>
              <description>[5:0] Minor Revision (Y)@@ maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R@@ S@@ X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless@@ the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCONFIG</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>Register AES_SYSCONFIG.This register configures the DMA signals and controls the IDLE and reset logic</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSSTATUS</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>SYSSTATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQSTATUS</name>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <description>This register indicates the interrupt status. If one of the interrupt bits is set the interrupt output will be asserted</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQENABLE</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>This register contains an enable bit for each unique interrupt generated by the module. It matches the layout of AES_IRQSTATUS register. An interrupt is enabled when the bit in this register is set to 1. An interrupt that is enabled is propagated to the SINTREQUEST_x output. All interrupts need to be enabled explicitly by writing this register. ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DES</name>
      <baseAddress>0x44039000</baseAddress>
      <registers>
        <register>
          <name>KEY3_L</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>KEY3 (LSW) for 192-bit key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY3_H</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>KEY3 (MSW) for 192-bit key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_L</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>KEY2 (LSW) for 192-bit key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY2_H</name>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <description>KEY2 (MSW) for 192-bit key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_L</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>KEY1 (LSW) for 128-bit key/192-bit key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY1_H</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>KEY1 (LSW) for 128-bit key/192-bit key</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IV_L</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Initialization vector LSW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IV_H</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>Initialization vector MSW</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>CTRL</description>
          <fields>
            <field>
              <name>MODE</name>
              <description>[5:4] Select CBC ECB or CFB mode 0x0 ecb mode 0x1 cbc mode 0x2 cfb mode 0x3 reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LENGTH</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Indicates the cryptographic data length in bytes for all modes. Once processing is started with this context this length decrements to zero. Data lengths up to (2^32  1) bytes are allowed. A write to this register triggers the engine to start using this context. For a Host read operation these registers return all-zeroes.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA_L</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Data register(LSW) to read/write encrypted/decrypted data.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DATA_H</name>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <description>Data register(MSW) to read/write encrypted/decrypted data.</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REVISION</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>REVISION</description>
          <fields>
            <field>
              <name>SCHEME</name>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>FUNC</name>
              <description>[27:16] Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>R_RTL</name>
              <description>[15:11] RTL Version (R) maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>X_MAJOR</name>
              <description>[10:8] Major Revision (X) maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CUSTOM</name>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Y_MINOR</name>
              <description>[5:0] Minor Revision (Y) maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R S X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSCONFIG</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>SYSCONFIG</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYSSTATUS</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>SYSSTATUS</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQSTATUS</name>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <description>This register indicates the interrupt status. If one of the interrupt bits is set the interrupt output will be asserted</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQENABLE</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>This register contains an enable bit for each unique interrupt generated by the module. It matches the layout of DES_IRQSTATUS register. An interrupt is enabled when the bit in this register is set to 1 ****************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>NVIC</name>
      <baseAddress>0xE000E000</baseAddress>
      <registers>
        <register>
          <name>INT_TYPE</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Interrupt Controller Type Reg</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACTLR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Auxiliary Control</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST_CTRL</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>SysTick Control and Status Register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST_RELOAD</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>SysTick Reload Value Register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST_CURRENT</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>SysTick Current Value Register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST_CAL</name>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <description>SysTick Calibration Value Reg</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN0</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Interrupt 0-31 Set Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN1</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>Interrupt 32-54 Set Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN2</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>Interrupt 64-95 Set Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN3</name>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <description>Interrupt 96-127 Set Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN4</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>Interrupt 128-131 Set Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EN5</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>Interrupt 160-191 Set Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIS0</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>Interrupt 0-31 Clear Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIS1</name>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <description>Interrupt 32-54 Clear Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIS2</name>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <description>Interrupt 64-95 Clear Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIS3</name>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <description>Interrupt 96-127 Clear Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIS4</name>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <description>Interrupt 128-131 Clear Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIS5</name>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <description>Interrupt 160-191 Clear Enable</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PEND0</name>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <description>Interrupt 0-31 Set Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PEND1</name>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <description>Interrupt 32-54 Set Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PEND2</name>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <description>Interrupt 64-95 Set Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PEND3</name>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <description>Interrupt 96-127 Set Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PEND4</name>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <description>Interrupt 128-131 Set Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PEND5</name>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <description>Interrupt 160-191 Set Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UNPEND0</name>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <description>Interrupt 0-31 Clear Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UNPEND1</name>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <description>Interrupt 32-54 Clear Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UNPEND2</name>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <description>Interrupt 64-95 Clear Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UNPEND3</name>
          <addressOffset>0x28C</addressOffset>
          <size>32</size>
          <description>Interrupt 96-127 Clear Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UNPEND4</name>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <description>Interrupt 128-131 Clear Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UNPEND5</name>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <description>Interrupt 160-191 Clear Pending</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACTIVE0</name>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <description>Interrupt 0-31 Active Bit</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACTIVE1</name>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <description>Interrupt 32-54 Active Bit</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACTIVE2</name>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <description>Interrupt 64-95 Active Bit</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACTIVE3</name>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <description>Interrupt 96-127 Active Bit</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACTIVE4</name>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <description>Interrupt 128-131 Active Bit</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ACTIVE5</name>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <description>Interrupt 160-191 Active Bit</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI0</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>Interrupt 0-3 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI1</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>Interrupt 4-7 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI2</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>Interrupt 8-11 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI3</name>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <description>Interrupt 12-15 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI4</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>Interrupt 16-19 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI5</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>Interrupt 20-23 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI6</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>Interrupt 24-27 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI7</name>
          <addressOffset>0x41C</addressOffset>
          <size>32</size>
          <description>Interrupt 28-31 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI8</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>Interrupt 32-35 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI9</name>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <description>Interrupt 36-39 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI10</name>
          <addressOffset>0x428</addressOffset>
          <size>32</size>
          <description>Interrupt 40-43 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI11</name>
          <addressOffset>0x42C</addressOffset>
          <size>32</size>
          <description>Interrupt 44-47 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI12</name>
          <addressOffset>0x430</addressOffset>
          <size>32</size>
          <description>Interrupt 48-51 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI13</name>
          <addressOffset>0x434</addressOffset>
          <size>32</size>
          <description>Interrupt 52-53 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI14</name>
          <addressOffset>0x438</addressOffset>
          <size>32</size>
          <description>Interrupt 56-59 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI15</name>
          <addressOffset>0x43C</addressOffset>
          <size>32</size>
          <description>Interrupt 60-63 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI16</name>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <description>Interrupt 64-67 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI17</name>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <description>Interrupt 68-71 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI18</name>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <description>Interrupt 72-75 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI19</name>
          <addressOffset>0x44C</addressOffset>
          <size>32</size>
          <description>Interrupt 76-79 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI20</name>
          <addressOffset>0x450</addressOffset>
          <size>32</size>
          <description>Interrupt 80-83 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI21</name>
          <addressOffset>0x454</addressOffset>
          <size>32</size>
          <description>Interrupt 84-87 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI22</name>
          <addressOffset>0x458</addressOffset>
          <size>32</size>
          <description>Interrupt 88-91 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI23</name>
          <addressOffset>0x45C</addressOffset>
          <size>32</size>
          <description>Interrupt 92-95 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI24</name>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <description>Interrupt 96-99 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI25</name>
          <addressOffset>0x464</addressOffset>
          <size>32</size>
          <description>Interrupt 100-103 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI26</name>
          <addressOffset>0x468</addressOffset>
          <size>32</size>
          <description>Interrupt 104-107 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI27</name>
          <addressOffset>0x46C</addressOffset>
          <size>32</size>
          <description>Interrupt 108-111 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI28</name>
          <addressOffset>0x470</addressOffset>
          <size>32</size>
          <description>Interrupt 112-115 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI29</name>
          <addressOffset>0x474</addressOffset>
          <size>32</size>
          <description>Interrupt 116-119 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI30</name>
          <addressOffset>0x478</addressOffset>
          <size>32</size>
          <description>Interrupt 120-123 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI31</name>
          <addressOffset>0x47C</addressOffset>
          <size>32</size>
          <description>Interrupt 124-127 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI32</name>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <description>Interrupt 128-131 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI33</name>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <description>Interrupt 132-135 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI34</name>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <description>Interrupt 136-139 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI35</name>
          <addressOffset>0x48C</addressOffset>
          <size>32</size>
          <description>Interrupt 140-143 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI36</name>
          <addressOffset>0x490</addressOffset>
          <size>32</size>
          <description>Interrupt 144-147 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI37</name>
          <addressOffset>0x494</addressOffset>
          <size>32</size>
          <description>Interrupt 148-151 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI38</name>
          <addressOffset>0x498</addressOffset>
          <size>32</size>
          <description>Interrupt 152-155 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI39</name>
          <addressOffset>0x49C</addressOffset>
          <size>32</size>
          <description>Interrupt 156-159 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI40</name>
          <addressOffset>0x4A0</addressOffset>
          <size>32</size>
          <description>Interrupt 160-163 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI41</name>
          <addressOffset>0x4A4</addressOffset>
          <size>32</size>
          <description>Interrupt 164-167 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI42</name>
          <addressOffset>0x4A8</addressOffset>
          <size>32</size>
          <description>Interrupt 168-171 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI43</name>
          <addressOffset>0x4AC</addressOffset>
          <size>32</size>
          <description>Interrupt 172-175 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI44</name>
          <addressOffset>0x4B0</addressOffset>
          <size>32</size>
          <description>Interrupt 176-179 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI45</name>
          <addressOffset>0x4B4</addressOffset>
          <size>32</size>
          <description>Interrupt 180-183 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI46</name>
          <addressOffset>0x4B8</addressOffset>
          <size>32</size>
          <description>Interrupt 184-187 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI47</name>
          <addressOffset>0x4BC</addressOffset>
          <size>32</size>
          <description>Interrupt 188-191 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRI48</name>
          <addressOffset>0x4C0</addressOffset>
          <size>32</size>
          <description>Interrupt 192-195 Priority</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CPUID</name>
          <addressOffset>0xD00</addressOffset>
          <size>32</size>
          <description>CPU ID Base</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>INT_CTRL</name>
          <addressOffset>0xD04</addressOffset>
          <size>32</size>
          <description>Interrupt Control and State</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>VTABLE</name>
          <addressOffset>0xD08</addressOffset>
          <size>32</size>
          <description>Vector Table Offset</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>APINT</name>
          <addressOffset>0xD0C</addressOffset>
          <size>32</size>
          <description>Application Interrupt and Reset Control</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYS_CTRL</name>
          <addressOffset>0xD10</addressOffset>
          <size>32</size>
          <description>System Control</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CFG_CTRL</name>
          <addressOffset>0xD14</addressOffset>
          <size>32</size>
          <description>Configuration and Control</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYS_PRI1</name>
          <addressOffset>0xD18</addressOffset>
          <size>32</size>
          <description>System Handler Priority 1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYS_PRI2</name>
          <addressOffset>0xD1C</addressOffset>
          <size>32</size>
          <description>System Handler Priority 2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYS_PRI3</name>
          <addressOffset>0xD20</addressOffset>
          <size>32</size>
          <description>System Handler Priority 3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYS_HND_CTRL</name>
          <addressOffset>0xD24</addressOffset>
          <size>32</size>
          <description>System Handler Control and State</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FAULT_STAT</name>
          <addressOffset>0xD28</addressOffset>
          <size>32</size>
          <description>Configurable Fault Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HFAULT_STAT</name>
          <addressOffset>0xD2C</addressOffset>
          <size>32</size>
          <description>Hard Fault Status</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DEBUG_STAT</name>
          <addressOffset>0xD30</addressOffset>
          <size>32</size>
          <description>Debug Status Register</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MM_ADDR</name>
          <addressOffset>0xD34</addressOffset>
          <size>32</size>
          <description>Memory Management Fault Address</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FAULT_ADDR</name>
          <addressOffset>0xD38</addressOffset>
          <size>32</size>
          <description>Bus Fault Address</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_TYPE</name>
          <addressOffset>0xD90</addressOffset>
          <size>32</size>
          <description>MPU Type</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_CTRL</name>
          <addressOffset>0xD94</addressOffset>
          <size>32</size>
          <description>MPU Control</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_NUMBER</name>
          <addressOffset>0xD98</addressOffset>
          <size>32</size>
          <description>MPU Region Number</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_BASE</name>
          <addressOffset>0xD9C</addressOffset>
          <size>32</size>
          <description>MPU Region Base Address</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_ATTR</name>
          <addressOffset>0xDA0</addressOffset>
          <size>32</size>
          <description>MPU Region Attribute and Size</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_BASE1</name>
          <addressOffset>0xDA4</addressOffset>
          <size>32</size>
          <description>MPU Region Base Address Alias 1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_ATTR1</name>
          <addressOffset>0xDA8</addressOffset>
          <size>32</size>
          <description>MPU Region Attribute and Size Alias 1</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_BASE2</name>
          <addressOffset>0xDAC</addressOffset>
          <size>32</size>
          <description>MPU Region Base Address Alias 2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_ATTR2</name>
          <addressOffset>0xDB0</addressOffset>
          <size>32</size>
          <description>MPU Region Attribute and Size Alias 2</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_BASE3</name>
          <addressOffset>0xDB4</addressOffset>
          <size>32</size>
          <description>MPU Region Base Address Alias 3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MPU_ATTR3</name>
          <addressOffset>0xDB8</addressOffset>
          <size>32</size>
          <description>MPU Region Attribute and Size Alias 3</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DBG_CTRL</name>
          <addressOffset>0xDF0</addressOffset>
          <size>32</size>
          <description>Debug Control and Status Reg</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DBG_XFER</name>
          <addressOffset>0xDF4</addressOffset>
          <size>32</size>
          <description>Debug Core Reg. Transfer Select</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DBG_DATA</name>
          <addressOffset>0xDF8</addressOffset>
          <size>32</size>
          <description>Debug Core Register Data</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DBG_INT</name>
          <addressOffset>0xDFC</addressOffset>
          <size>32</size>
          <description>Debug Reset Interrupt Control</description>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SW_TRIG</name>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <description>Software Trigger Interrupt ***************************************************************************</description>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>